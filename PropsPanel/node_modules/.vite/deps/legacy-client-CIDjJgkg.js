import { c as hydration_mismatch, d as lifecycle_double_unmount, g as state_proxy_unmount, u as legacy_recursive_reactive_block, y as true_default } from "./warnings-Ds7e8mX2.js";
import { $n as TEMPLATE_FRAGMENT, An as set_hydrate_node, Cn as hydrate_next, Ct as mutable_source, Dr as DIRTY, En as hydrating, Hn as HYDRATION_ERROR, Ir as MAYBE_DIRTY, Kn as NAMESPACE_MATHML, Kr as is_array, Lr as STATE_SYMBOL, Or as DOCUMENT_FRAGMENT_NODE, Pr as LEGACY_PROPS, Rr as TEXT_NODE, Tr as COMMENT_NODE, Tt as set, Un as HYDRATION_START, Ut as boundary, Vn as HYDRATION_END, Vr as define_property, Xt as flushSync, Yr as noop, an as dev_current_component_function, at as create_comment, b as set_signal_status, br as lifecycle_outside_component, ct as create_text, dn as pop, dt as get_next_sibling, er as TEMPLATE_USE_IMPORT_NODE, fn as push, fr as hydration_failed, ft as init_operations, h as get, it as clear_text_content, jn as set_hydrating, k as component_root, kr as EFFECT_RAN, l as root_event_handles, mt as set_attribute, nr as TEMPLATE_USE_SVG, o as handle_event_propagation, ot as create_element, pt as is_firefox, q as user_pre_effect, qn as NAMESPACE_SVG, rn as component_context, s as on, st as create_fragment, t as all_registered_events, tr as TEMPLATE_USE_MATHML, u as active_effect, ut as get_first_child, wn as hydrate_node, zn as FILENAME, zr as array_from } from "./events-CwpACFa3.js";
import { t as async_mode_flag } from "./flags-ZndxuwIb.js";

//#region node_modules/svelte/src/utils.js
var regex_return_characters = /\r/g;
/**
* @param {string} str
* @returns {string}
*/
function hash(str) {
	str = str.replace(regex_return_characters, "");
	let hash$1 = 5381;
	let i = str.length;
	while (i--) hash$1 = (hash$1 << 5) - hash$1 ^ str.charCodeAt(i);
	return (hash$1 >>> 0).toString(36);
}
var VOID_ELEMENT_NAMES = [
	"area",
	"base",
	"br",
	"col",
	"command",
	"embed",
	"hr",
	"img",
	"input",
	"keygen",
	"link",
	"meta",
	"param",
	"source",
	"track",
	"wbr"
];
/**
* Returns `true` if `name` is of a void element
* @param {string} name
*/
function is_void(name) {
	return VOID_ELEMENT_NAMES.includes(name) || name.toLowerCase() === "!doctype";
}
/**
* @param {string} name
*/
function is_capture_event(name) {
	return name.endsWith("capture") && name !== "gotpointercapture" && name !== "lostpointercapture";
}
/** List of Element events that will be delegated */
var DELEGATED_EVENTS = [
	"beforeinput",
	"click",
	"change",
	"dblclick",
	"contextmenu",
	"focusin",
	"focusout",
	"input",
	"keydown",
	"keyup",
	"mousedown",
	"mousemove",
	"mouseout",
	"mouseover",
	"mouseup",
	"pointerdown",
	"pointermove",
	"pointerout",
	"pointerover",
	"pointerup",
	"touchend",
	"touchmove",
	"touchstart"
];
/**
* Returns `true` if `event_name` is a delegated event
* @param {string} event_name
*/
function can_delegate_event(event_name) {
	return DELEGATED_EVENTS.includes(event_name);
}
/**
* Attributes that are boolean, i.e. they are present or not present.
*/
var DOM_BOOLEAN_ATTRIBUTES = [
	"allowfullscreen",
	"async",
	"autofocus",
	"autoplay",
	"checked",
	"controls",
	"default",
	"disabled",
	"formnovalidate",
	"indeterminate",
	"inert",
	"ismap",
	"loop",
	"multiple",
	"muted",
	"nomodule",
	"novalidate",
	"open",
	"playsinline",
	"readonly",
	"required",
	"reversed",
	"seamless",
	"selected",
	"webkitdirectory",
	"defer",
	"disablepictureinpicture",
	"disableremoteplayback"
];
/**
* @type {Record<string, string>}
* List of attribute names that should be aliased to their property names
* because they behave differently between setting them as an attribute and
* setting them as a property.
*/
var ATTRIBUTE_ALIASES = {
	formnovalidate: "formNoValidate",
	ismap: "isMap",
	nomodule: "noModule",
	playsinline: "playsInline",
	readonly: "readOnly",
	defaultvalue: "defaultValue",
	defaultchecked: "defaultChecked",
	srcobject: "srcObject",
	novalidate: "noValidate",
	allowfullscreen: "allowFullscreen",
	disablepictureinpicture: "disablePictureInPicture",
	disableremoteplayback: "disableRemotePlayback"
};
/**
* @param {string} name
*/
function normalize_attribute(name) {
	name = name.toLowerCase();
	return ATTRIBUTE_ALIASES[name] ?? name;
}
var DOM_PROPERTIES = [
	...DOM_BOOLEAN_ATTRIBUTES,
	"formNoValidate",
	"isMap",
	"noModule",
	"playsInline",
	"readOnly",
	"value",
	"volume",
	"defaultValue",
	"defaultChecked",
	"srcObject",
	"noValidate",
	"allowFullscreen",
	"disablePictureInPicture",
	"disableRemotePlayback"
];
/**
* Subset of delegated events which should be passive by default.
* These two are already passive via browser defaults on window, document and body.
* But since
* - we're delegating them
* - they happen often
* - they apply to mobile which is generally less performant
* we're marking them as passive by default for other elements, too.
*/
var PASSIVE_EVENTS = ["touchstart", "touchmove"];
/**
* Returns `true` if `name` is a passive event
* @param {string} name
*/
function is_passive_event(name) {
	return PASSIVE_EVENTS.includes(name);
}
var STATE_CREATION_RUNES = [
	"$state",
	"$state.raw",
	"$derived",
	"$derived.by"
];
var RUNES = [
	...STATE_CREATION_RUNES,
	"$state.eager",
	"$state.snapshot",
	"$props",
	"$props.id",
	"$bindable",
	"$effect",
	"$effect.pre",
	"$effect.tracking",
	"$effect.root",
	"$effect.pending",
	"$inspect",
	"$inspect().with",
	"$inspect.trace",
	"$host"
];
/** List of elements that require raw contents and should not have SSR comments put in them */
var RAW_TEXT_ELEMENTS = [
	"textarea",
	"script",
	"style",
	"title"
];
/** @param {string} name */
function is_raw_text_element(name) {
	return RAW_TEXT_ELEMENTS.includes(name);
}
/**
* Prevent devtools trying to make `location` a clickable link by inserting a zero-width space
* @template {string | undefined} T
* @param {T} location
* @returns {T};
*/
function sanitize_location(location) {
	return location?.replace(/\//g, "/​");
}

//#endregion
//#region node_modules/svelte/src/internal/client/dom/reconciler.js
/** @param {string} html */
function create_fragment_from_html(html) {
	var elem = document.createElement("template");
	elem.innerHTML = html.replaceAll("<!>", "<!---->");
	return elem.content;
}

//#endregion
//#region node_modules/svelte/src/internal/client/dom/template.js
/** @import { Effect, TemplateNode } from '#client' */
/** @import { TemplateStructure } from './types' */
/**
* @param {TemplateNode} start
* @param {TemplateNode | null} end
*/
function assign_nodes(start, end) {
	var effect = active_effect;
	if (effect.nodes_start === null) {
		effect.nodes_start = start;
		effect.nodes_end = end;
	}
}
/**
* @param {string} content
* @param {number} flags
* @returns {() => Node | Node[]}
*/
/* @__NO_SIDE_EFFECTS__ */
function from_html(content, flags) {
	var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
	var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;
	/** @type {Node} */
	var node;
	/**
	* Whether or not the first item is a text/element node. If not, we need to
	* create an additional comment node to act as `effect.nodes.start`
	*/
	var has_start = !content.startsWith("<!>");
	return () => {
		if (hydrating) {
			assign_nodes(hydrate_node, null);
			return hydrate_node;
		}
		if (node === void 0) {
			node = create_fragment_from_html(has_start ? content : "<!>" + content);
			if (!is_fragment) node = /* @__PURE__ */ get_first_child(node);
		}
		var clone = use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true);
		if (is_fragment) {
			var start = /* @__PURE__ */ get_first_child(clone);
			var end = clone.lastChild;
			assign_nodes(start, end);
		} else assign_nodes(clone, clone);
		return clone;
	};
}
/**
* @param {string} content
* @param {number} flags
* @param {'svg' | 'math'} ns
* @returns {() => Node | Node[]}
*/
/* @__NO_SIDE_EFFECTS__ */
function from_namespace(content, flags, ns = "svg") {
	/**
	* Whether or not the first item is a text/element node. If not, we need to
	* create an additional comment node to act as `effect.nodes.start`
	*/
	var has_start = !content.startsWith("<!>");
	var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
	var wrapped = `<${ns}>${has_start ? content : "<!>" + content}</${ns}>`;
	/** @type {Element | DocumentFragment} */
	var node;
	return () => {
		if (hydrating) {
			assign_nodes(hydrate_node, null);
			return hydrate_node;
		}
		if (!node) {
			var root = /* @__PURE__ */ get_first_child(create_fragment_from_html(wrapped));
			if (is_fragment) {
				node = document.createDocumentFragment();
				while (/* @__PURE__ */ get_first_child(root)) node.appendChild(/* @__PURE__ */ get_first_child(root));
			} else node = /* @__PURE__ */ get_first_child(root);
		}
		var clone = node.cloneNode(true);
		if (is_fragment) {
			var start = /* @__PURE__ */ get_first_child(clone);
			var end = clone.lastChild;
			assign_nodes(start, end);
		} else assign_nodes(clone, clone);
		return clone;
	};
}
/**
* @param {string} content
* @param {number} flags
*/
/* @__NO_SIDE_EFFECTS__ */
function from_svg(content, flags) {
	return /* @__PURE__ */ from_namespace(content, flags, "svg");
}
/**
* @param {string} content
* @param {number} flags
*/
/* @__NO_SIDE_EFFECTS__ */
function from_mathml(content, flags) {
	return /* @__PURE__ */ from_namespace(content, flags, "math");
}
/**
* @param {TemplateStructure[]} structure
* @param {typeof NAMESPACE_SVG | typeof NAMESPACE_MATHML | undefined} [ns]
*/
function fragment_from_tree(structure, ns) {
	var fragment = create_fragment();
	for (var item of structure) {
		if (typeof item === "string") {
			fragment.append(create_text(item));
			continue;
		}
		if (item === void 0 || item[0][0] === "/") {
			fragment.append(create_comment(item ? item[0].slice(3) : ""));
			continue;
		}
		const [name, attributes, ...children] = item;
		const namespace = name === "svg" ? NAMESPACE_SVG : name === "math" ? NAMESPACE_MATHML : ns;
		var element = create_element(name, namespace, attributes?.is);
		for (var key in attributes) set_attribute(element, key, attributes[key]);
		if (children.length > 0) (element.tagName === "TEMPLATE" ? element.content : element).append(fragment_from_tree(children, element.tagName === "foreignObject" ? void 0 : namespace));
		fragment.append(element);
	}
	return fragment;
}
/**
* @param {TemplateStructure[]} structure
* @param {number} flags
* @returns {() => Node | Node[]}
*/
/* @__NO_SIDE_EFFECTS__ */
function from_tree(structure, flags) {
	var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
	var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;
	/** @type {Node} */
	var node;
	return () => {
		if (hydrating) {
			assign_nodes(hydrate_node, null);
			return hydrate_node;
		}
		if (node === void 0) {
			node = fragment_from_tree(structure, (flags & TEMPLATE_USE_SVG) !== 0 ? NAMESPACE_SVG : (flags & TEMPLATE_USE_MATHML) !== 0 ? NAMESPACE_MATHML : void 0);
			if (!is_fragment) node = /* @__PURE__ */ get_first_child(node);
		}
		var clone = use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true);
		if (is_fragment) {
			var start = /* @__PURE__ */ get_first_child(clone);
			var end = clone.lastChild;
			assign_nodes(start, end);
		} else assign_nodes(clone, clone);
		return clone;
	};
}
/**
* @param {() => Element | DocumentFragment} fn
*/
function with_script(fn) {
	return () => run_scripts(fn());
}
/**
* Creating a document fragment from HTML that contains script tags will not execute
* the scripts. We need to replace the script tags with new ones so that they are executed.
* @param {Element | DocumentFragment} node
* @returns {Node | Node[]}
*/
function run_scripts(node) {
	if (hydrating) return node;
	const is_fragment = node.nodeType === DOCUMENT_FRAGMENT_NODE;
	const scripts = node.tagName === "SCRIPT" ? [node] : node.querySelectorAll("script");
	const effect = active_effect;
	for (const script of scripts) {
		const clone = document.createElement("script");
		for (var attribute of script.attributes) clone.setAttribute(attribute.name, attribute.value);
		clone.textContent = script.textContent;
		if (is_fragment ? node.firstChild === script : node === script) effect.nodes_start = clone;
		if (is_fragment ? node.lastChild === script : node === script) effect.nodes_end = clone;
		script.replaceWith(clone);
	}
	return node;
}
/**
* Don't mark this as side-effect-free, hydration needs to walk all nodes
* @param {any} value
*/
function text(value = "") {
	if (!hydrating) {
		var t = create_text(value + "");
		assign_nodes(t, t);
		return t;
	}
	var node = hydrate_node;
	if (node.nodeType !== TEXT_NODE) {
		node.before(node = create_text());
		set_hydrate_node(node);
	}
	assign_nodes(node, node);
	return node;
}
/**
* @returns {TemplateNode | DocumentFragment}
*/
function comment() {
	if (hydrating) {
		assign_nodes(hydrate_node, null);
		return hydrate_node;
	}
	var frag = document.createDocumentFragment();
	var start = document.createComment("");
	var anchor = create_text();
	frag.append(start, anchor);
	assign_nodes(start, anchor);
	return frag;
}
/**
* Assign the created (or in hydration mode, traversed) dom elements to the current block
* and insert the elements into the dom (in client mode).
* @param {Text | Comment | Element} anchor
* @param {DocumentFragment | Element} dom
*/
function append(anchor, dom) {
	if (hydrating) {
		var effect = active_effect;
		if ((effect.f & EFFECT_RAN) === 0 || effect.nodes_end === null) effect.nodes_end = hydrate_node;
		hydrate_next();
		return;
	}
	if (anchor === null) return;
	anchor.before(dom);
}
/**
* Create (or hydrate) an unique UID for the component instance.
*/
function props_id() {
	if (hydrating && hydrate_node && hydrate_node.nodeType === COMMENT_NODE && hydrate_node.textContent?.startsWith(`$`)) {
		const id = hydrate_node.textContent.substring(1);
		hydrate_next();
		return id;
	}
	(window.__svelte ??= {}).uid ??= 1;
	return `c${window.__svelte.uid++}`;
}

//#endregion
//#region node_modules/svelte/src/internal/client/render.js
/** @import { ComponentContext, Effect, TemplateNode } from '#client' */
/** @import { Component, ComponentType, SvelteComponent, MountOptions } from '../../index.js' */
/**
* This is normally true — block effects should run their intro transitions —
* but is false during hydration (unless `options.intro` is `true`) and
* when creating the children of a `<svelte:element>` that just changed tag
*/
let should_intro = true;
/** @param {boolean} value */
function set_should_intro(value) {
	should_intro = value;
}
/**
* @param {Element} text
* @param {string} value
* @returns {void}
*/
function set_text(text$1, value) {
	var str = value == null ? "" : typeof value === "object" ? value + "" : value;
	if (str !== (text$1.__t ??= text$1.nodeValue)) {
		text$1.__t = str;
		text$1.nodeValue = str + "";
	}
}
/**
* Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component.
* Transitions will play during the initial render unless the `intro` option is set to `false`.
*
* @template {Record<string, any>} Props
* @template {Record<string, any>} Exports
* @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component
* @param {MountOptions<Props>} options
* @returns {Exports}
*/
function mount(component, options) {
	return _mount(component, options);
}
/**
* Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component
*
* @template {Record<string, any>} Props
* @template {Record<string, any>} Exports
* @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component
* @param {{} extends Props ? {
* 		target: Document | Element | ShadowRoot;
* 		props?: Props;
* 		events?: Record<string, (e: any) => any>;
*  	context?: Map<any, any>;
* 		intro?: boolean;
* 		recover?: boolean;
* 	} : {
* 		target: Document | Element | ShadowRoot;
* 		props: Props;
* 		events?: Record<string, (e: any) => any>;
*  	context?: Map<any, any>;
* 		intro?: boolean;
* 		recover?: boolean;
* 	}} options
* @returns {Exports}
*/
function hydrate(component, options) {
	init_operations();
	options.intro = options.intro ?? false;
	const target = options.target;
	const was_hydrating = hydrating;
	const previous_hydrate_node = hydrate_node;
	try {
		var anchor = /* @__PURE__ */ get_first_child(target);
		while (anchor && (anchor.nodeType !== COMMENT_NODE || anchor.data !== HYDRATION_START)) anchor = /* @__PURE__ */ get_next_sibling(anchor);
		if (!anchor) throw HYDRATION_ERROR;
		set_hydrating(true);
		set_hydrate_node(anchor);
		const instance = _mount(component, {
			...options,
			anchor
		});
		set_hydrating(false);
		return instance;
	} catch (error) {
		if (error instanceof Error && error.message.split("\n").some((line) => line.startsWith("https://svelte.dev/e/"))) throw error;
		if (error !== HYDRATION_ERROR) console.warn("Failed to hydrate: ", error);
		if (options.recover === false) hydration_failed();
		init_operations();
		clear_text_content(target);
		set_hydrating(false);
		return mount(component, options);
	} finally {
		set_hydrating(was_hydrating);
		set_hydrate_node(previous_hydrate_node);
	}
}
/** @type {Map<string, number>} */
var document_listeners = /* @__PURE__ */ new Map();
/**
* @template {Record<string, any>} Exports
* @param {ComponentType<SvelteComponent<any>> | Component<any>} Component
* @param {MountOptions} options
* @returns {Exports}
*/
function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
	init_operations();
	/** @type {Set<string>} */
	var registered_events = /* @__PURE__ */ new Set();
	/** @param {Array<string>} events */
	var event_handle = (events$1) => {
		for (var i = 0; i < events$1.length; i++) {
			var event_name = events$1[i];
			if (registered_events.has(event_name)) continue;
			registered_events.add(event_name);
			var passive$1 = is_passive_event(event_name);
			target.addEventListener(event_name, handle_event_propagation, { passive: passive$1 });
			var n = document_listeners.get(event_name);
			if (n === void 0) {
				document.addEventListener(event_name, handle_event_propagation, { passive: passive$1 });
				document_listeners.set(event_name, 1);
			} else document_listeners.set(event_name, n + 1);
		}
	};
	event_handle(array_from(all_registered_events));
	root_event_handles.add(event_handle);
	/** @type {Exports} */
	var component = void 0;
	var unmount$1 = component_root(() => {
		var anchor_node = anchor ?? target.appendChild(create_text());
		boundary(anchor_node, { pending: () => {} }, (anchor_node$1) => {
			if (context) {
				push({});
				var ctx = component_context;
				ctx.c = context;
			}
			if (events)
 /** @type {any} */ props.$$events = events;
			if (hydrating) assign_nodes(anchor_node$1, null);
			should_intro = intro;
			component = Component(anchor_node$1, props) || {};
			should_intro = true;
			if (hydrating) {
				/** @type {Effect} */ active_effect.nodes_end = hydrate_node;
				if (hydrate_node === null || hydrate_node.nodeType !== COMMENT_NODE || hydrate_node.data !== HYDRATION_END) {
					hydration_mismatch();
					throw HYDRATION_ERROR;
				}
			}
			if (context) pop();
		});
		return () => {
			for (var event_name of registered_events) {
				target.removeEventListener(event_name, handle_event_propagation);
				var n = document_listeners.get(event_name);
				if (--n === 0) {
					document.removeEventListener(event_name, handle_event_propagation);
					document_listeners.delete(event_name);
				} else document_listeners.set(event_name, n);
			}
			root_event_handles.delete(event_handle);
			if (anchor_node !== anchor) anchor_node.parentNode?.removeChild(anchor_node);
		};
	});
	mounted_components.set(component, unmount$1);
	return component;
}
/**
* References of the components that were mounted or hydrated.
* Uses a `WeakMap` to avoid memory leaks.
*/
var mounted_components = /* @__PURE__ */ new WeakMap();
/**
* Unmounts a component that was previously mounted using `mount` or `hydrate`.
*
* Since 5.13.0, if `options.outro` is `true`, [transitions](https://svelte.dev/docs/svelte/transition) will play before the component is removed from the DOM.
*
* Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
*
* ```js
* import { mount, unmount } from 'svelte';
* import App from './App.svelte';
*
* const app = mount(App, { target: document.body });
*
* // later...
* unmount(app, { outro: true });
* ```
* @param {Record<string, any>} component
* @param {{ outro?: boolean }} [options]
* @returns {Promise<void>}
*/
function unmount(component, options) {
	const fn = mounted_components.get(component);
	if (fn) {
		mounted_components.delete(component);
		return fn(options);
	}
	if (true_default) if (STATE_SYMBOL in component) state_proxy_unmount();
	else lifecycle_double_unmount();
	return Promise.resolve();
}

//#endregion
//#region node_modules/svelte/src/internal/client/dom/legacy/event-modifiers.js
/**
* Substitute for the `trusted` event modifier
* @deprecated
* @param {(event: Event, ...args: Array<unknown>) => void} fn
* @returns {(event: Event, ...args: unknown[]) => void}
*/
function trusted(fn) {
	return function(...args) {
		if (args[0].isTrusted) fn?.apply(this, args);
	};
}
/**
* Substitute for the `self` event modifier
* @deprecated
* @param {(event: Event, ...args: Array<unknown>) => void} fn
* @returns {(event: Event, ...args: unknown[]) => void}
*/
function self(fn) {
	return function(...args) {
		if (args[0].target === this) fn?.apply(this, args);
	};
}
/**
* Substitute for the `stopPropagation` event modifier
* @deprecated
* @param {(event: Event, ...args: Array<unknown>) => void} fn
* @returns {(event: Event, ...args: unknown[]) => void}
*/
function stopPropagation(fn) {
	return function(...args) {
		args[0].stopPropagation();
		return fn?.apply(this, args);
	};
}
/**
* Substitute for the `once` event modifier
* @deprecated
* @param {(event: Event, ...args: Array<unknown>) => void} fn
* @returns {(event: Event, ...args: unknown[]) => void}
*/
function once(fn) {
	var ran = false;
	return function(...args) {
		if (ran) return;
		ran = true;
		return fn?.apply(this, args);
	};
}
/**
* Substitute for the `stopImmediatePropagation` event modifier
* @deprecated
* @param {(event: Event, ...args: Array<unknown>) => void} fn
* @returns {(event: Event, ...args: unknown[]) => void}
*/
function stopImmediatePropagation(fn) {
	return function(...args) {
		args[0].stopImmediatePropagation();
		return fn?.apply(this, args);
	};
}
/**
* Substitute for the `preventDefault` event modifier
* @deprecated
* @param {(event: Event, ...args: Array<unknown>) => void} fn
* @returns {(event: Event, ...args: unknown[]) => void}
*/
function preventDefault(fn) {
	return function(...args) {
		args[0].preventDefault();
		return fn?.apply(this, args);
	};
}
/**
* Substitute for the `passive` event modifier, implemented as an action
* @deprecated
* @param {HTMLElement} node
* @param {[event: string, handler: () => EventListener]} options
*/
function passive(node, [event, handler]) {
	user_pre_effect(() => {
		return on(node, event, handler() ?? noop, { passive: true });
	});
}
/**
* Substitute for the `nonpassive` event modifier, implemented as an action
* @deprecated
* @param {HTMLElement} node
* @param {[event: string, handler: () => EventListener]} options
*/
function nonpassive(node, [event, handler]) {
	user_pre_effect(() => {
		return on(node, event, handler() ?? noop, { passive: false });
	});
}

//#endregion
//#region node_modules/svelte/src/legacy/legacy-client.js
/** @import { ComponentConstructorOptions, ComponentType, SvelteComponent, Component } from 'svelte' */
/**
* Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.
*
* @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5.
*
* @template {Record<string, any>} Props
* @template {Record<string, any>} Exports
* @template {Record<string, any>} Events
* @template {Record<string, any>} Slots
*
* @param {ComponentConstructorOptions<Props> & {
* 	component: ComponentType<SvelteComponent<Props, Events, Slots>> | Component<Props>;
* }} options
* @returns {SvelteComponent<Props, Events, Slots> & Exports}
*/
function createClassComponent(options) {
	return new Svelte4Component(options);
}
/**
* Takes the component function and returns a Svelte 4 compatible component constructor.
*
* @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5.
*
* @template {Record<string, any>} Props
* @template {Record<string, any>} Exports
* @template {Record<string, any>} Events
* @template {Record<string, any>} Slots
*
* @param {SvelteComponent<Props, Events, Slots> | Component<Props>} component
* @returns {ComponentType<SvelteComponent<Props, Events, Slots> & Exports>}
*/
function asClassComponent(component) {
	return class extends Svelte4Component {
		/** @param {any} options */
		constructor(options) {
			super({
				component,
				...options
			});
		}
	};
}
/**
* Support using the component as both a class and function during the transition period
* @typedef  {{new (o: ComponentConstructorOptions): SvelteComponent;(...args: Parameters<Component<Record<string, any>>>): ReturnType<Component<Record<string, any>, Record<string, any>>>;}} LegacyComponentType
*/
var Svelte4Component = class {
	/** @type {any} */
	#events;
	/** @type {Record<string, any>} */
	#instance;
	/**
	* @param {ComponentConstructorOptions & {
	*  component: any;
	* }} options
	*/
	constructor(options) {
		var sources = /* @__PURE__ */ new Map();
		/**
		* @param {string | symbol} key
		* @param {unknown} value
		*/
		var add_source = (key, value) => {
			var s = /* @__PURE__ */ mutable_source(value, false, false);
			sources.set(key, s);
			return s;
		};
		const props = new Proxy({
			...options.props || {},
			$$events: {}
		}, {
			get(target, prop) {
				return get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));
			},
			has(target, prop) {
				if (prop === LEGACY_PROPS) return true;
				get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));
				return Reflect.has(target, prop);
			},
			set(target, prop, value) {
				set(sources.get(prop) ?? add_source(prop, value), value);
				return Reflect.set(target, prop, value);
			}
		});
		this.#instance = (options.hydrate ? hydrate : mount)(options.component, {
			target: options.target,
			anchor: options.anchor,
			props,
			context: options.context,
			intro: options.intro ?? false,
			recover: options.recover
		});
		if (!async_mode_flag && (!options?.props?.$$host || options.sync === false)) flushSync();
		this.#events = props.$$events;
		for (const key of Object.keys(this.#instance)) {
			if (key === "$set" || key === "$destroy" || key === "$on") continue;
			define_property(this, key, {
				get() {
					return this.#instance[key];
				},
				set(value) {
					this.#instance[key] = value;
				},
				enumerable: true
			});
		}
		this.#instance.$set = (next) => {
			Object.assign(props, next);
		};
		this.#instance.$destroy = () => {
			unmount(this.#instance);
		};
	}
	/** @param {Record<string, any>} props */
	$set(props) {
		this.#instance.$set(props);
	}
	/**
	* @param {string} event
	* @param {(...args: any[]) => any} callback
	* @returns {any}
	*/
	$on(event, callback) {
		this.#events[event] = this.#events[event] || [];
		/** @param {any[]} args */
		const cb = (...args) => callback.call(this, ...args);
		this.#events[event].push(cb);
		return () => {
			this.#events[event] = this.#events[event].filter(
				/** @param {any} fn */
				(fn) => fn !== cb
			);
		};
	}
	$destroy() {
		this.#instance.$destroy();
	}
};
/**
* Runs the given function once immediately on the server, and works like `$effect.pre` on the client.
*
* @deprecated Use this only as a temporary solution to migrate your component code to Svelte 5.
* @param {() => void | (() => void)} fn
* @returns {void}
*/
function run(fn) {
	user_pre_effect(() => {
		fn();
		var effect = active_effect;
		if ((effect.f & DIRTY) !== 0) {
			let filename = "a file (we can't know which one)";
			if (true_default) filename = dev_current_component_function?.[FILENAME] ?? filename;
			legacy_recursive_reactive_block(filename);
			set_signal_status(effect, MAYBE_DIRTY);
		}
	});
}
/**
* Function to mimic the multiple listeners available in svelte 4
* @deprecated
* @param {EventListener[]} handlers
* @returns {EventListener}
*/
function handlers(...handlers$1) {
	return function(event) {
		const { stopImmediatePropagation: stopImmediatePropagation$1 } = event;
		let stopped = false;
		event.stopImmediatePropagation = () => {
			stopped = true;
			stopImmediatePropagation$1.call(event);
		};
		const errors = [];
		for (const handler of handlers$1) {
			try {
				handler?.call(this, event);
			} catch (e) {
				errors.push(e);
			}
			if (stopped) break;
		}
		for (let error of errors) queueMicrotask(() => {
			throw error;
		});
	};
}
/**
* Function to create a `bubble` function that mimic the behavior of `on:click` without handler available in svelte 4.
* @deprecated Use this only as a temporary solution to migrate your automatically delegated events in Svelte 5.
*/
function createBubbler() {
	const active_component_context = component_context;
	if (active_component_context === null) lifecycle_outside_component("createBubbler");
	return (type) => (event) => {
		const events = active_component_context.s.$$events?.[type];
		if (events) {
			const callbacks = is_array(events) ? events.slice() : [events];
			for (const fn of callbacks) fn.call(active_component_context.x, event);
			return !event.defaultPrevented;
		}
		return true;
	};
}

//#endregion
export { create_fragment_from_html as A, from_html as C, props_id as D, from_tree as E, is_void as F, normalize_attribute as I, sanitize_location as L, hash as M, is_capture_event as N, text as O, is_raw_text_element as P, comment as S, from_svg as T, set_text as _, run as a, append as b, passive as c, stopImmediatePropagation as d, stopPropagation as f, set_should_intro as g, mount as h, handlers as i, can_delegate_event as j, with_script as k, preventDefault as l, hydrate as m, createBubbler as n, nonpassive as o, trusted as p, createClassComponent as r, once as s, asClassComponent as t, self as u, should_intro as v, from_mathml as w, assign_nodes as x, unmount as y };
//# sourceMappingURL=legacy-client-CIDjJgkg.js.map