import { _ as svelte_boundary_reset_noop, a as event_handler_invalid, c as hydration_mismatch, h as state_proxy_equality_mismatch, n as await_waterfall, y as true_default } from "./warnings-Ds7e8mX2.js";
import { a as legacy_mode_flag, o as tracing_mode_flag, t as async_mode_flag } from "./flags-ZndxuwIb.js";

//#region node_modules/svelte/src/internal/shared/utils.js
var is_array = Array.isArray;
var index_of = Array.prototype.indexOf;
var array_from = Array.from;
var object_keys = Object.keys;
var define_property = Object.defineProperty;
var get_descriptor = Object.getOwnPropertyDescriptor;
var get_descriptors = Object.getOwnPropertyDescriptors;
var object_prototype = Object.prototype;
var array_prototype = Array.prototype;
var get_prototype_of = Object.getPrototypeOf;
var is_extensible = Object.isExtensible;
/**
* @param {any} thing
* @returns {thing is Function}
*/
function is_function(thing) {
	return typeof thing === "function";
}
const noop = () => {};
/**
* @template [T=any]
* @param {any} value
* @returns {value is PromiseLike<T>}
*/
function is_promise(value) {
	return typeof value?.then === "function";
}
/** @param {Function} fn */
function run$1(fn) {
	return fn();
}
/** @param {Array<() => void>} arr */
function run_all(arr) {
	for (var i = 0; i < arr.length; i++) arr[i]();
}
/**
* TODO replace with Promise.withResolvers once supported widely enough
* @template T
*/
function deferred() {
	/** @type {(value: T) => void} */
	var resolve;
	/** @type {(reason: any) => void} */
	var reject;
	return {
		promise: new Promise((res, rej) => {
			resolve = res;
			reject = rej;
		}),
		resolve,
		reject
	};
}
/**
* @template V
* @param {V} value
* @param {V | (() => V)} fallback
* @param {boolean} [lazy]
* @returns {V}
*/
function fallback(value, fallback$1, lazy = false) {
	return value === void 0 ? lazy ? fallback$1() : fallback$1 : value;
}
/**
* When encountering a situation like `let [a, b, c] = $derived(blah())`,
* we need to stash an intermediate value that `a`, `b`, and `c` derive
* from, in case it's an iterable
* @template T
* @param {ArrayLike<T> | Iterable<T>} value
* @param {number} [n]
* @returns {Array<T>}
*/
function to_array(value, n) {
	if (Array.isArray(value)) return value;
	if (n === void 0 || !(Symbol.iterator in value)) return Array.from(value);
	/** @type {T[]} */
	const array = [];
	for (const element of value) {
		array.push(element);
		if (array.length === n) break;
	}
	return array;
}

//#endregion
//#region node_modules/svelte/src/internal/client/constants.js
const DERIVED = 2;
const EFFECT = 4;
const RENDER_EFFECT = 8;
const BLOCK_EFFECT = 16;
const BRANCH_EFFECT = 32;
const ROOT_EFFECT = 64;
const BOUNDARY_EFFECT = 128;
/**
* Indicates that a reaction is connected to an effect root — either it is an effect,
* or it is a derived that is depended on by at least one effect. If a derived has
* no dependents, we can disconnect it from the graph, allowing it to either be
* GC'd or reconnected later if an effect comes to depend on it again
*/
const CONNECTED = 512;
const CLEAN = 1024;
const DIRTY = 2048;
const MAYBE_DIRTY = 4096;
const INERT = 8192;
const DESTROYED = 16384;
/** Set once an effect that should run synchronously has run */
const EFFECT_RAN = 32768;
/**
* 'Transparent' effects do not create a transition boundary.
* This is on a block effect 99% of the time but may also be on a branch effect if its parent block effect was pruned
*/
const EFFECT_TRANSPARENT = 65536;
const EAGER_EFFECT = 1 << 17;
const HEAD_EFFECT = 1 << 18;
const EFFECT_PRESERVED = 1 << 19;
const USER_EFFECT = 1 << 20;
/**
* Tells that we marked this derived and its reactions as visited during the "mark as (maybe) dirty"-phase.
* Will be lifted during execution of the derived and during checking its dirty state (both are necessary
* because a derived might be checked but not executed).
*/
const WAS_MARKED = 32768;
const REACTION_IS_UPDATING = 1 << 21;
const ASYNC = 1 << 22;
const ERROR_VALUE = 1 << 23;
const STATE_SYMBOL = Symbol("$state");
const LEGACY_PROPS = Symbol("legacy props");
const LOADING_ATTR_SYMBOL = Symbol("");
const PROXY_PATH_SYMBOL = Symbol("proxy path");
/** allow users to ignore aborted signal errors if `reason.name === 'StaleReactionError` */
const STALE_REACTION = new class StaleReactionError extends Error {
	name = "StaleReactionError";
	message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}();
const ELEMENT_NODE = 1;
const TEXT_NODE = 3;
const COMMENT_NODE = 8;
const DOCUMENT_FRAGMENT_NODE = 11;

//#endregion
//#region node_modules/svelte/src/internal/shared/errors.js
/**
* Cannot use `{@render children(...)}` if the parent component uses `let:` directives. Consider using a named snippet instead
* @returns {never}
*/
function invalid_default_snippet() {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`invalid_default_snippet\nCannot use \`{@render children(...)}\` if the parent component uses \`let:\` directives. Consider using a named snippet instead\nhttps://svelte.dev/e/invalid_default_snippet`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/invalid_default_snippet`);
}
/**
* A snippet function was passed invalid arguments. Snippets should only be instantiated via `{@render ...}`
* @returns {never}
*/
function invalid_snippet_arguments() {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`invalid_snippet_arguments\nA snippet function was passed invalid arguments. Snippets should only be instantiated via \`{@render ...}\`\nhttps://svelte.dev/e/invalid_snippet_arguments`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/invalid_snippet_arguments`);
}
/**
* `%name%(...)` can only be used during component initialisation
* @param {string} name
* @returns {never}
*/
function lifecycle_outside_component(name) {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`lifecycle_outside_component\n\`${name}(...)\` can only be used during component initialisation\nhttps://svelte.dev/e/lifecycle_outside_component`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/lifecycle_outside_component`);
}
/**
* Context was not set in a parent component
* @returns {never}
*/
function missing_context() {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`missing_context\nContext was not set in a parent component\nhttps://svelte.dev/e/missing_context`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/missing_context`);
}
/**
* Attempted to render a snippet without a `{@render}` block. This would cause the snippet code to be stringified instead of its content being rendered to the DOM. To fix this, change `{snippet}` to `{@render snippet()}`.
* @returns {never}
*/
function snippet_without_render_tag() {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`snippet_without_render_tag\nAttempted to render a snippet without a \`{@render}\` block. This would cause the snippet code to be stringified instead of its content being rendered to the DOM. To fix this, change \`{snippet}\` to \`{@render snippet()}\`.\nhttps://svelte.dev/e/snippet_without_render_tag`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/snippet_without_render_tag`);
}
/**
* `%name%` is not a store with a `subscribe` method
* @param {string} name
* @returns {never}
*/
function store_invalid_shape(name) {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`store_invalid_shape\n\`${name}\` is not a store with a \`subscribe\` method\nhttps://svelte.dev/e/store_invalid_shape`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/store_invalid_shape`);
}
/**
* The `this` prop on `<svelte:element>` must be a string, if defined
* @returns {never}
*/
function svelte_element_invalid_this_value() {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`svelte_element_invalid_this_value\nThe \`this\` prop on \`<svelte:element>\` must be a string, if defined\nhttps://svelte.dev/e/svelte_element_invalid_this_value`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/svelte_element_invalid_this_value`);
}

//#endregion
//#region node_modules/svelte/src/internal/client/errors.js
/**
* Cannot create a `$derived(...)` with an `await` expression outside of an effect tree
* @returns {never}
*/
function async_derived_orphan() {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`async_derived_orphan\nCannot create a \`$derived(...)\` with an \`await\` expression outside of an effect tree\nhttps://svelte.dev/e/async_derived_orphan`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/async_derived_orphan`);
}
/**
* Using `bind:value` together with a checkbox input is not allowed. Use `bind:checked` instead
* @returns {never}
*/
function bind_invalid_checkbox_value() {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`bind_invalid_checkbox_value\nUsing \`bind:value\` together with a checkbox input is not allowed. Use \`bind:checked\` instead\nhttps://svelte.dev/e/bind_invalid_checkbox_value`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/bind_invalid_checkbox_value`);
}
/**
* Calling `%method%` on a component instance (of %component%) is no longer valid in Svelte 5
* @param {string} method
* @param {string} component
* @returns {never}
*/
function component_api_changed(method, component) {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`component_api_changed\nCalling \`${method}\` on a component instance (of ${component}) is no longer valid in Svelte 5\nhttps://svelte.dev/e/component_api_changed`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/component_api_changed`);
}
/**
* Attempted to instantiate %component% with `new %name%`, which is no longer valid in Svelte 5. If this component is not under your control, set the `compatibility.componentApi` compiler option to `4` to keep it working.
* @param {string} component
* @param {string} name
* @returns {never}
*/
function component_api_invalid_new(component, name) {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`component_api_invalid_new\nAttempted to instantiate ${component} with \`new ${name}\`, which is no longer valid in Svelte 5. If this component is not under your control, set the \`compatibility.componentApi\` compiler option to \`4\` to keep it working.\nhttps://svelte.dev/e/component_api_invalid_new`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/component_api_invalid_new`);
}
/**
* A derived value cannot reference itself recursively
* @returns {never}
*/
function derived_references_self() {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`derived_references_self\nA derived value cannot reference itself recursively\nhttps://svelte.dev/e/derived_references_self`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/derived_references_self`);
}
/**
* Keyed each block has duplicate key `%value%` at indexes %a% and %b%
* @param {string} a
* @param {string} b
* @param {string | undefined | null} [value]
* @returns {never}
*/
function each_key_duplicate(a, b, value) {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`each_key_duplicate\n${value ? `Keyed each block has duplicate key \`${value}\` at indexes ${a} and ${b}` : `Keyed each block has duplicate key at indexes ${a} and ${b}`}\nhttps://svelte.dev/e/each_key_duplicate`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/each_key_duplicate`);
}
/**
* `%rune%` cannot be used inside an effect cleanup function
* @param {string} rune
* @returns {never}
*/
function effect_in_teardown(rune) {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`effect_in_teardown\n\`${rune}\` cannot be used inside an effect cleanup function\nhttps://svelte.dev/e/effect_in_teardown`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/effect_in_teardown`);
}
/**
* Effect cannot be created inside a `$derived` value that was not itself created inside an effect
* @returns {never}
*/
function effect_in_unowned_derived() {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`effect_in_unowned_derived\nEffect cannot be created inside a \`$derived\` value that was not itself created inside an effect\nhttps://svelte.dev/e/effect_in_unowned_derived`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/effect_in_unowned_derived`);
}
/**
* `%rune%` can only be used inside an effect (e.g. during component initialisation)
* @param {string} rune
* @returns {never}
*/
function effect_orphan(rune) {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`effect_orphan\n\`${rune}\` can only be used inside an effect (e.g. during component initialisation)\nhttps://svelte.dev/e/effect_orphan`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/effect_orphan`);
}
/**
* `$effect.pending()` can only be called inside an effect or derived
* @returns {never}
*/
function effect_pending_outside_reaction() {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`effect_pending_outside_reaction\n\`$effect.pending()\` can only be called inside an effect or derived\nhttps://svelte.dev/e/effect_pending_outside_reaction`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/effect_pending_outside_reaction`);
}
/**
* Maximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state
* @returns {never}
*/
function effect_update_depth_exceeded() {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`effect_update_depth_exceeded\nMaximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state\nhttps://svelte.dev/e/effect_update_depth_exceeded`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
}
/**
* Cannot use `fork(...)` unless the `experimental.async` compiler option is `true`
* @returns {never}
*/
function experimental_async_fork() {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`experimental_async_fork\nCannot use \`fork(...)\` unless the \`experimental.async\` compiler option is \`true\`\nhttps://svelte.dev/e/experimental_async_fork`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/experimental_async_fork`);
}
/**
* Cannot use `flushSync` inside an effect
* @returns {never}
*/
function flush_sync_in_effect() {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`flush_sync_in_effect\nCannot use \`flushSync\` inside an effect\nhttps://svelte.dev/e/flush_sync_in_effect`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/flush_sync_in_effect`);
}
/**
* Cannot commit a fork that was already discarded
* @returns {never}
*/
function fork_discarded() {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`fork_discarded\nCannot commit a fork that was already discarded\nhttps://svelte.dev/e/fork_discarded`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/fork_discarded`);
}
/**
* Cannot create a fork inside an effect or when state changes are pending
* @returns {never}
*/
function fork_timing() {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`fork_timing\nCannot create a fork inside an effect or when state changes are pending\nhttps://svelte.dev/e/fork_timing`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/fork_timing`);
}
/**
* `getAbortSignal()` can only be called inside an effect or derived
* @returns {never}
*/
function get_abort_signal_outside_reaction() {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`get_abort_signal_outside_reaction\n\`getAbortSignal()\` can only be called inside an effect or derived\nhttps://svelte.dev/e/get_abort_signal_outside_reaction`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/get_abort_signal_outside_reaction`);
}
/**
* Failed to hydrate the application
* @returns {never}
*/
function hydration_failed() {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`hydration_failed\nFailed to hydrate the application\nhttps://svelte.dev/e/hydration_failed`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/hydration_failed`);
}
/**
* Could not `{@render}` snippet due to the expression being `null` or `undefined`. Consider using optional chaining `{@render snippet?.()}`
* @returns {never}
*/
function invalid_snippet() {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`invalid_snippet\nCould not \`{@render}\` snippet due to the expression being \`null\` or \`undefined\`. Consider using optional chaining \`{@render snippet?.()}\`\nhttps://svelte.dev/e/invalid_snippet`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/invalid_snippet`);
}
/**
* `%name%(...)` cannot be used in runes mode
* @param {string} name
* @returns {never}
*/
function lifecycle_legacy_only(name) {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`lifecycle_legacy_only\n\`${name}(...)\` cannot be used in runes mode\nhttps://svelte.dev/e/lifecycle_legacy_only`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/lifecycle_legacy_only`);
}
/**
* Cannot do `bind:%key%={undefined}` when `%key%` has a fallback value
* @param {string} key
* @returns {never}
*/
function props_invalid_value(key) {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`props_invalid_value\nCannot do \`bind:${key}={undefined}\` when \`${key}\` has a fallback value\nhttps://svelte.dev/e/props_invalid_value`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/props_invalid_value`);
}
/**
* Rest element properties of `$props()` such as `%property%` are readonly
* @param {string} property
* @returns {never}
*/
function props_rest_readonly(property) {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`props_rest_readonly\nRest element properties of \`$props()\` such as \`${property}\` are readonly\nhttps://svelte.dev/e/props_rest_readonly`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/props_rest_readonly`);
}
/**
* The `%rune%` rune is only available inside `.svelte` and `.svelte.js/ts` files
* @param {string} rune
* @returns {never}
*/
function rune_outside_svelte(rune) {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`rune_outside_svelte\nThe \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files\nhttps://svelte.dev/e/rune_outside_svelte`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/rune_outside_svelte`);
}
/**
* `setContext` must be called when a component first initializes, not in a subsequent effect or after an `await` expression
* @returns {never}
*/
function set_context_after_init() {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`set_context_after_init\n\`setContext\` must be called when a component first initializes, not in a subsequent effect or after an \`await\` expression\nhttps://svelte.dev/e/set_context_after_init`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/set_context_after_init`);
}
/**
* Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.
* @returns {never}
*/
function state_descriptors_fixed() {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`state_descriptors_fixed\nProperty descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.\nhttps://svelte.dev/e/state_descriptors_fixed`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
}
/**
* Cannot set prototype of `$state` object
* @returns {never}
*/
function state_prototype_fixed() {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`state_prototype_fixed\nCannot set prototype of \`$state\` object\nhttps://svelte.dev/e/state_prototype_fixed`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
}
/**
* Updating state inside `$derived(...)`, `$inspect(...)` or a template expression is forbidden. If the value should not be reactive, declare it without `$state`
* @returns {never}
*/
function state_unsafe_mutation() {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`state_unsafe_mutation\nUpdating state inside \`$derived(...)\`, \`$inspect(...)\` or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`\nhttps://svelte.dev/e/state_unsafe_mutation`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
}
/**
* A `<svelte:boundary>` `reset` function cannot be called while an error is still being handled
* @returns {never}
*/
function svelte_boundary_reset_onerror() {
	if (true_default) {
		const error = /* @__PURE__ */ new Error(`svelte_boundary_reset_onerror\nA \`<svelte:boundary>\` \`reset\` function cannot be called while an error is still being handled\nhttps://svelte.dev/e/svelte_boundary_reset_onerror`);
		error.name = "Svelte error";
		throw error;
	} else throw new Error(`https://svelte.dev/e/svelte_boundary_reset_onerror`);
}

//#endregion
//#region node_modules/svelte/src/constants.js
const EACH_ITEM_REACTIVE = 1;
const EACH_INDEX_REACTIVE = 2;
/** See EachBlock interface metadata.is_controlled for an explanation what this is */
const EACH_IS_CONTROLLED = 4;
const EACH_IS_ANIMATED = 8;
const EACH_ITEM_IMMUTABLE = 16;
const PROPS_IS_IMMUTABLE = 1;
const PROPS_IS_RUNES = 2;
const PROPS_IS_UPDATED = 4;
const PROPS_IS_BINDABLE = 8;
const PROPS_IS_LAZY_INITIAL = 16;
const TRANSITION_IN = 1;
const TRANSITION_OUT = 2;
const TRANSITION_GLOBAL = 4;
const TEMPLATE_FRAGMENT = 1;
const TEMPLATE_USE_IMPORT_NODE = 2;
const TEMPLATE_USE_SVG = 4;
const TEMPLATE_USE_MATHML = 8;
const HYDRATION_START = "[";
/** used to indicate that an `{:else}...` block was rendered */
const HYDRATION_START_ELSE = "[!";
const HYDRATION_END = "]";
const HYDRATION_ERROR = {};
const UNINITIALIZED = Symbol();
const FILENAME = Symbol("filename");
const HMR = Symbol("hmr");
const NAMESPACE_HTML = "http://www.w3.org/1999/xhtml";
const NAMESPACE_SVG = "http://www.w3.org/2000/svg";
const NAMESPACE_MATHML = "http://www.w3.org/1998/Math/MathML";
const ATTACHMENT_KEY = "@attach";

//#endregion
//#region node_modules/svelte/src/internal/client/dom/hydration.js
/** @import { TemplateNode } from '#client' */
/**
* Use this variable to guard everything related to hydration code so it can be treeshaken out
* if the user doesn't use the `hydrate` method and these code paths are therefore not needed.
*/
let hydrating = false;
/** @param {boolean} value */
function set_hydrating(value) {
	hydrating = value;
}
/**
* The node that is currently being hydrated. This starts out as the first node inside the opening
* <!--[--> comment, and updates each time a component calls `$.child(...)` or `$.sibling(...)`.
* When entering a block (e.g. `{#if ...}`), `hydrate_node` is the block opening comment; by the
* time we leave the block it is the closing comment, which serves as the block's anchor.
* @type {TemplateNode}
*/
let hydrate_node;
/** @param {TemplateNode} node */
function set_hydrate_node(node) {
	if (node === null) {
		hydration_mismatch();
		throw HYDRATION_ERROR;
	}
	return hydrate_node = node;
}
function hydrate_next() {
	return set_hydrate_node(/* @__PURE__ */ get_next_sibling(hydrate_node));
}
/** @param {TemplateNode} node */
function reset(node) {
	if (!hydrating) return;
	if (/* @__PURE__ */ get_next_sibling(hydrate_node) !== null) {
		hydration_mismatch();
		throw HYDRATION_ERROR;
	}
	hydrate_node = node;
}
/**
* @param {HTMLTemplateElement} template
*/
function hydrate_template(template) {
	if (hydrating) hydrate_node = template.content;
}
function next(count = 1) {
	if (hydrating) {
		var i = count;
		var node = hydrate_node;
		while (i--) node = /* @__PURE__ */ get_next_sibling(node);
		hydrate_node = node;
	}
}
/**
* Skips or removes (depending on {@link remove}) all nodes starting at `hydrate_node` up until the next hydration end comment
* @param {boolean} remove
*/
function skip_nodes(remove = true) {
	var depth = 0;
	var node = hydrate_node;
	while (true) {
		if (node.nodeType === COMMENT_NODE) {
			var data = node.data;
			if (data === HYDRATION_END) {
				if (depth === 0) return node;
				depth -= 1;
			} else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) depth += 1;
		}
		var next$1 = /* @__PURE__ */ get_next_sibling(node);
		if (remove) node.remove();
		node = next$1;
	}
}
/**
*
* @param {TemplateNode} node
*/
function read_hydration_instruction(node) {
	if (!node || node.nodeType !== COMMENT_NODE) {
		hydration_mismatch();
		throw HYDRATION_ERROR;
	}
	return node.data;
}

//#endregion
//#region node_modules/svelte/src/internal/client/reactivity/equality.js
/** @import { Equals } from '#client' */
/** @type {Equals} */
function equals$1(value) {
	return value === this.v;
}
/**
* @param {unknown} a
* @param {unknown} b
* @returns {boolean}
*/
function safe_not_equal(a, b) {
	return a != a ? b == b : a !== b || a !== null && typeof a === "object" || typeof a === "function";
}
/** @type {Equals} */
function safe_equals(value) {
	return !safe_not_equal(value, this.v);
}

//#endregion
//#region node_modules/svelte/src/internal/shared/warnings.js
var bold = "font-weight: bold";
var normal = "font-weight: normal";
/**
* `<svelte:element this="%tag%">` is a void element — it cannot have content
* @param {string} tag
*/
function dynamic_void_element_content(tag$1) {
	if (true_default) console.warn(`%c[svelte] dynamic_void_element_content\n%c\`<svelte:element this="${tag$1}">\` is a void element — it cannot have content\nhttps://svelte.dev/e/dynamic_void_element_content`, bold, normal);
	else console.warn(`https://svelte.dev/e/dynamic_void_element_content`);
}
/**
* The following properties cannot be cloned with `$state.snapshot` — the return value contains the originals:
* 
* %properties%
* @param {string | undefined | null} [properties]
*/
function state_snapshot_uncloneable(properties) {
	if (true_default) console.warn(`%c[svelte] state_snapshot_uncloneable\n%c${properties ? `The following properties cannot be cloned with \`$state.snapshot\` — the return value contains the originals:

${properties}` : "Value cannot be cloned with `$state.snapshot` — the original value was returned"}\nhttps://svelte.dev/e/state_snapshot_uncloneable`, bold, normal);
	else console.warn(`https://svelte.dev/e/state_snapshot_uncloneable`);
}

//#endregion
//#region node_modules/svelte/src/internal/shared/clone.js
/** @import { Snapshot } from './types' */
/**
* In dev, we keep track of which properties could not be cloned. In prod
* we don't bother, but we keep a dummy array around so that the
* signature stays the same
* @type {string[]}
*/
var empty = [];
/**
* @template T
* @param {T} value
* @param {boolean} [skip_warning]
* @param {boolean} [no_tojson]
* @returns {Snapshot<T>}
*/
function snapshot(value, skip_warning = false, no_tojson = false) {
	if (true_default && !skip_warning) {
		/** @type {string[]} */
		const paths = [];
		const copy = clone(value, /* @__PURE__ */ new Map(), "", paths, null, no_tojson);
		if (paths.length === 1 && paths[0] === "") state_snapshot_uncloneable();
		else if (paths.length > 0) {
			const slice = paths.length > 10 ? paths.slice(0, 7) : paths.slice(0, 10);
			const excess = paths.length - slice.length;
			let uncloned = slice.map((path) => `- <value>${path}`).join("\n");
			if (excess > 0) uncloned += `\n- ...and ${excess} more`;
			state_snapshot_uncloneable(uncloned);
		}
		return copy;
	}
	return clone(value, /* @__PURE__ */ new Map(), "", empty, null, no_tojson);
}
/**
* @template T
* @param {T} value
* @param {Map<T, Snapshot<T>>} cloned
* @param {string} path
* @param {string[]} paths
* @param {null | T} [original] The original value, if `value` was produced from a `toJSON` call
* @param {boolean} [no_tojson]
* @returns {Snapshot<T>}
*/
function clone(value, cloned, path, paths, original = null, no_tojson = false) {
	if (typeof value === "object" && value !== null) {
		var unwrapped = cloned.get(value);
		if (unwrapped !== void 0) return unwrapped;
		if (value instanceof Map) return new Map(value);
		if (value instanceof Set) return new Set(value);
		if (is_array(value)) {
			var copy = Array(value.length);
			cloned.set(value, copy);
			if (original !== null) cloned.set(original, copy);
			for (var i = 0; i < value.length; i += 1) {
				var element = value[i];
				if (i in value) copy[i] = clone(element, cloned, true_default ? `${path}[${i}]` : path, paths, null, no_tojson);
			}
			return copy;
		}
		if (get_prototype_of(value) === object_prototype) {
			/** @type {Snapshot<any>} */
			copy = {};
			cloned.set(value, copy);
			if (original !== null) cloned.set(original, copy);
			for (var key in value) copy[key] = clone(value[key], cloned, true_default ? `${path}.${key}` : path, paths, null, no_tojson);
			return copy;
		}
		if (value instanceof Date) return structuredClone(value);
		if (typeof value.toJSON === "function" && !no_tojson) return clone(
			/** @type {T & { toJSON(): any } } */
			value.toJSON(),
			cloned,
			true_default ? `${path}.toJSON()` : path,
			paths,
			value
		);
	}
	if (value instanceof EventTarget) return value;
	try {
		return structuredClone(value);
	} catch (e) {
		if (true_default) paths.push(path);
		return value;
	}
}

//#endregion
//#region node_modules/svelte/src/internal/client/dev/tracing.js
/** @import { Derived, Reaction, Value } from '#client' */
/**
* @typedef {{
*   traces: Error[];
* }} TraceEntry
*/
/** @type {{ reaction: Reaction | null, entries: Map<Value, TraceEntry> } | null} */
let tracing_expressions = null;
/**
* @param {Value} signal
* @param {TraceEntry} [entry]
*/
function log_entry(signal, entry) {
	const value = signal.v;
	if (value === UNINITIALIZED) return;
	const type = get_type(signal);
	const current_reaction = active_reaction;
	const dirty = signal.wv > current_reaction.wv || current_reaction.wv === 0;
	const style = dirty ? "color: CornflowerBlue; font-weight: bold" : "color: grey; font-weight: normal";
	console.groupCollapsed(signal.label ? `%c${type}%c ${signal.label}` : `%c${type}%c`, style, dirty ? "font-weight: normal" : style, typeof value === "object" && value !== null && STATE_SYMBOL in value ? snapshot(value, true) : value);
	if (type === "$derived") {
		const deps = new Set(
			/** @type {Derived} */
			signal.deps
		);
		for (const dep of deps) log_entry(dep);
	}
	if (signal.created) console.log(signal.created);
	if (dirty && signal.updated) for (const updated of signal.updated.values()) console.log(updated.error);
	if (entry) for (var trace$1 of entry.traces) console.log(trace$1);
	console.groupEnd();
}
/**
* @param {Value} signal
* @returns {'$state' | '$derived' | 'store'}
*/
function get_type(signal) {
	if ((signal.f & (DERIVED | ASYNC)) !== 0) return "$derived";
	return signal.label?.startsWith("$") ? "store" : "$state";
}
/**
* @template T
* @param {() => string} label
* @param {() => T} fn
*/
function trace(label$1, fn) {
	var previously_tracing_expressions = tracing_expressions;
	try {
		tracing_expressions = {
			entries: /* @__PURE__ */ new Map(),
			reaction: active_reaction
		};
		var start = performance.now();
		var value = fn();
		var time = (performance.now() - start).toFixed(2);
		var prefix = untrack(label$1);
		if (!effect_tracking()) console.log(`${prefix} %cran outside of an effect (${time}ms)`, "color: grey");
		else if (tracing_expressions.entries.size === 0) console.log(`${prefix} %cno reactive dependencies (${time}ms)`, "color: grey");
		else {
			console.group(`${prefix} %c(${time}ms)`, "color: grey");
			var entries = tracing_expressions.entries;
			untrack(() => {
				for (const [signal, traces] of entries) log_entry(signal, traces);
			});
			tracing_expressions = null;
			console.groupEnd();
		}
		return value;
	} finally {
		tracing_expressions = previously_tracing_expressions;
	}
}
/**
* @param {string} label
* @returns {Error & { stack: string } | null}
*/
function get_stack(label$1) {
	const limit = Error.stackTraceLimit;
	Error.stackTraceLimit = Infinity;
	let error = Error();
	Error.stackTraceLimit = limit;
	const stack$1 = error.stack;
	if (!stack$1) return null;
	const lines = stack$1.split("\n");
	const new_lines = ["\n"];
	for (let i = 0; i < lines.length; i++) {
		const line = lines[i];
		const posixified = line.replaceAll("\\", "/");
		if (line === "Error") continue;
		if (line.includes("validate_each_keys")) return null;
		if (posixified.includes("svelte/src/internal") || posixified.includes("node_modules/.vite")) continue;
		new_lines.push(line);
	}
	if (new_lines.length === 1) return null;
	define_property(error, "stack", { value: new_lines.join("\n") });
	define_property(error, "name", { value: label$1 });
	return error;
}
/**
* @param {Value} source
* @param {string} label
*/
function tag(source$1, label$1) {
	source$1.label = label$1;
	tag_proxy(source$1.v, label$1);
	return source$1;
}
/**
* @param {unknown} value
* @param {string} label
*/
function tag_proxy(value, label$1) {
	value?.[PROXY_PATH_SYMBOL]?.(label$1);
	return value;
}
/**
* @param {unknown} value
*/
function label(value) {
	if (typeof value === "symbol") return `Symbol(${value.description})`;
	if (typeof value === "function") return "<function>";
	if (typeof value === "object" && value) return "<object>";
	return String(value);
}

//#endregion
//#region node_modules/svelte/src/internal/client/context.js
/** @import { ComponentContext, DevStackEntry, Effect } from '#client' */
/** @type {ComponentContext | null} */
let component_context = null;
/** @param {ComponentContext | null} context */
function set_component_context(context) {
	component_context = context;
}
/** @type {DevStackEntry | null} */
let dev_stack = null;
/** @param {DevStackEntry | null} stack */
function set_dev_stack(stack$1) {
	dev_stack = stack$1;
}
/**
* Execute a callback with a new dev stack entry
* @param {() => any} callback - Function to execute
* @param {DevStackEntry['type']} type - Type of block/component
* @param {any} component - Component function
* @param {number} line - Line number
* @param {number} column - Column number
* @param {Record<string, any>} [additional] - Any additional properties to add to the dev stack entry
* @returns {any}
*/
function add_svelte_meta(callback, type, component, line, column, additional) {
	const parent = dev_stack;
	dev_stack = {
		type,
		file: component[FILENAME],
		line,
		column,
		parent,
		...additional
	};
	try {
		return callback();
	} finally {
		dev_stack = parent;
	}
}
/**
* The current component function. Different from current component context:
* ```html
* <!-- App.svelte -->
* <Foo>
*   <Bar /> <!-- context == Foo.svelte, function == App.svelte -->
* </Foo>
* ```
* @type {ComponentContext['function']}
*/
let dev_current_component_function = null;
/** @param {ComponentContext['function']} fn */
function set_dev_current_component_function(fn) {
	dev_current_component_function = fn;
}
/**
* Returns a `[get, set]` pair of functions for working with context in a type-safe way.
*
* `get` will throw an error if no parent component called `set`.
*
* @template T
* @returns {[() => T, (context: T) => T]}
* @since 5.40.0
*/
function createContext() {
	const key = {};
	return [() => {
		if (!hasContext(key)) missing_context();
		return getContext(key);
	}, (context) => setContext(key, context)];
}
/**
* Retrieves the context that belongs to the closest parent component with the specified `key`.
* Must be called during component initialisation.
*
* [`createContext`](https://svelte.dev/docs/svelte/svelte#createContext) is a type-safe alternative.
*
* @template T
* @param {any} key
* @returns {T}
*/
function getContext(key) {
	return get_or_init_context_map("getContext").get(key);
}
/**
* Associates an arbitrary `context` object with the current component and the specified `key`
* and returns that object. The context is then available to children of the component
* (including slotted content) with `getContext`.
*
* Like lifecycle functions, this must be called during component initialisation.
*
* [`createContext`](https://svelte.dev/docs/svelte/svelte#createContext) is a type-safe alternative.
*
* @template T
* @param {any} key
* @param {T} context
* @returns {T}
*/
function setContext(key, context) {
	const context_map = get_or_init_context_map("setContext");
	if (async_mode_flag) {
		var flags$1 = active_effect.f;
		if (!(!active_reaction && (flags$1 & BRANCH_EFFECT) !== 0 && !component_context.i)) set_context_after_init();
	}
	context_map.set(key, context);
	return context;
}
/**
* Checks whether a given `key` has been set in the context of a parent component.
* Must be called during component initialisation.
*
* @param {any} key
* @returns {boolean}
*/
function hasContext(key) {
	return get_or_init_context_map("hasContext").has(key);
}
/**
* Retrieves the whole context map that belongs to the closest parent component.
* Must be called during component initialisation. Useful, for example, if you
* programmatically create a component and want to pass the existing context to it.
*
* @template {Map<any, any>} [T=Map<any, any>]
* @returns {T}
*/
function getAllContexts() {
	return get_or_init_context_map("getAllContexts");
}
/**
* @param {Record<string, unknown>} props
* @param {any} runes
* @param {Function} [fn]
* @returns {void}
*/
function push(props, runes = false, fn) {
	component_context = {
		p: component_context,
		i: false,
		c: null,
		e: null,
		s: props,
		x: null,
		l: legacy_mode_flag && !runes ? {
			s: null,
			u: null,
			$: []
		} : null
	};
	if (true_default) {
		component_context.function = fn;
		dev_current_component_function = fn;
	}
}
/**
* @template {Record<string, any>} T
* @param {T} [component]
* @returns {T}
*/
function pop(component) {
	var context = component_context;
	var effects = context.e;
	if (effects !== null) {
		context.e = null;
		for (var fn of effects) create_user_effect(fn);
	}
	if (component !== void 0) context.x = component;
	context.i = true;
	component_context = context.p;
	if (true_default) dev_current_component_function = component_context?.function ?? null;
	return component ?? {};
}
/** @returns {boolean} */
function is_runes() {
	return !legacy_mode_flag || component_context !== null && component_context.l === null;
}
/**
* @param {string} name
* @returns {Map<unknown, unknown>}
*/
function get_or_init_context_map(name) {
	if (component_context === null) lifecycle_outside_component(name);
	return component_context.c ??= new Map(get_parent_context(component_context) || void 0);
}
/**
* @param {ComponentContext} component_context
* @returns {Map<unknown, unknown> | null}
*/
function get_parent_context(component_context$1) {
	let parent = component_context$1.p;
	while (parent !== null) {
		const context_map = parent.c;
		if (context_map !== null) return context_map;
		parent = parent.p;
	}
	return null;
}

//#endregion
//#region node_modules/svelte/src/internal/client/dom/task.js
/** @type {Array<() => void>} */
var micro_tasks = [];
function run_micro_tasks() {
	var tasks = micro_tasks;
	micro_tasks = [];
	run_all(tasks);
}
/**
* @param {() => void} fn
*/
function queue_micro_task(fn) {
	if (micro_tasks.length === 0 && !is_flushing_sync) {
		var tasks = micro_tasks;
		queueMicrotask(() => {
			if (tasks === micro_tasks) run_micro_tasks();
		});
	}
	micro_tasks.push(fn);
}
/**
* Synchronously run any queued tasks.
*/
function flush_tasks() {
	while (micro_tasks.length > 0) run_micro_tasks();
}

//#endregion
//#region node_modules/svelte/src/internal/client/error-handling.js
/** @import { Derived, Effect } from '#client' */
/** @import { Boundary } from './dom/blocks/boundary.js' */
var adjustments = /* @__PURE__ */ new WeakMap();
/**
* @param {unknown} error
*/
function handle_error(error) {
	var effect$1 = active_effect;
	if (effect$1 === null) {
		/** @type {Derived} */ active_reaction.f |= ERROR_VALUE;
		return error;
	}
	if (true_default && error instanceof Error && !adjustments.has(error)) adjustments.set(error, get_adjustments(error, effect$1));
	if ((effect$1.f & EFFECT_RAN) === 0) {
		if ((effect$1.f & BOUNDARY_EFFECT) === 0) {
			if (true_default && !effect$1.parent && error instanceof Error) apply_adjustments(error);
			throw error;
		}
		/** @type {Boundary} */ effect$1.b.error(error);
	} else invoke_error_boundary(error, effect$1);
}
/**
* @param {unknown} error
* @param {Effect | null} effect
*/
function invoke_error_boundary(error, effect$1) {
	while (effect$1 !== null) {
		if ((effect$1.f & BOUNDARY_EFFECT) !== 0) try {
			/** @type {Boundary} */ effect$1.b.error(error);
			return;
		} catch (e) {
			error = e;
		}
		effect$1 = effect$1.parent;
	}
	if (true_default && error instanceof Error) apply_adjustments(error);
	throw error;
}
/**
* Add useful information to the error message/stack in development
* @param {Error} error
* @param {Effect} effect
*/
function get_adjustments(error, effect$1) {
	const message_descriptor = get_descriptor(error, "message");
	if (message_descriptor && !message_descriptor.configurable) return;
	var indent = is_firefox ? "  " : "	";
	var component_stack = `\n${indent}in ${effect$1.fn?.name || "<unknown>"}`;
	var context = effect$1.ctx;
	while (context !== null) {
		component_stack += `\n${indent}in ${context.function?.[FILENAME].split("/").pop()}`;
		context = context.p;
	}
	return {
		message: error.message + `\n${component_stack}\n`,
		stack: error.stack?.split("\n").filter((line) => !line.includes("svelte/src/internal")).join("\n")
	};
}
/**
* @param {Error} error
*/
function apply_adjustments(error) {
	const adjusted = adjustments.get(error);
	if (adjusted) {
		define_property(error, "message", { value: adjusted.message });
		define_property(error, "stack", { value: adjusted.stack });
	}
}

//#endregion
//#region node_modules/svelte/src/internal/client/reactivity/batch.js
/** @import { Fork } from 'svelte' */
/** @import { Derived, Effect, Reaction, Source, Value } from '#client' */
/**
* @typedef {{
*   parent: EffectTarget | null;
*   effect: Effect | null;
*   effects: Effect[];
*   render_effects: Effect[];
*   block_effects: Effect[];
* }} EffectTarget
*/
/** @type {Set<Batch>} */
var batches = /* @__PURE__ */ new Set();
/** @type {Batch | null} */
let current_batch = null;
/**
* This is needed to avoid overwriting inputs in non-async mode
* TODO 6.0 remove this, as non-async mode will go away
* @type {Batch | null}
*/
let previous_batch = null;
/**
* When time travelling (i.e. working in one batch, while other batches
* still have ongoing work), we ignore the real values of affected
* signals in favour of their values within the batch
* @type {Map<Value, any> | null}
*/
let batch_values = null;
/** @type {Effect[]} */
var queued_root_effects = [];
/** @type {Effect | null} */
var last_scheduled_effect = null;
var is_flushing = false;
let is_flushing_sync = false;
var Batch = class Batch {
	committed = false;
	/**
	* The current values of any sources that are updated in this batch
	* They keys of this map are identical to `this.#previous`
	* @type {Map<Source, any>}
	*/
	current = /* @__PURE__ */ new Map();
	/**
	* The values of any sources that are updated in this batch _before_ those updates took place.
	* They keys of this map are identical to `this.#current`
	* @type {Map<Source, any>}
	*/
	previous = /* @__PURE__ */ new Map();
	/**
	* When the batch is committed (and the DOM is updated), we need to remove old branches
	* and append new ones by calling the functions added inside (if/each/key/etc) blocks
	* @type {Set<() => void>}
	*/
	#commit_callbacks = /* @__PURE__ */ new Set();
	/**
	* If a fork is discarded, we need to destroy any effects that are no longer needed
	* @type {Set<(batch: Batch) => void>}
	*/
	#discard_callbacks = /* @__PURE__ */ new Set();
	/**
	* The number of async effects that are currently in flight
	*/
	#pending = 0;
	/**
	* The number of async effects that are currently in flight, _not_ inside a pending boundary
	*/
	#blocking_pending = 0;
	/**
	* A deferred that resolves when the batch is committed, used with `settled()`
	* TODO replace with Promise.withResolvers once supported widely enough
	* @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
	*/
	#deferred = null;
	/**
	* Deferred effects (which run after async work has completed) that are DIRTY
	* @type {Effect[]}
	*/
	#dirty_effects = [];
	/**
	* Deferred effects that are MAYBE_DIRTY
	* @type {Effect[]}
	*/
	#maybe_dirty_effects = [];
	/**
	* A set of branches that still exist, but will be destroyed when this batch
	* is committed — we skip over these during `process`
	* @type {Set<Effect>}
	*/
	skipped_effects = /* @__PURE__ */ new Set();
	is_fork = false;
	/**
	*
	* @param {Effect[]} root_effects
	*/
	process(root_effects) {
		queued_root_effects = [];
		previous_batch = null;
		this.apply();
		/** @type {EffectTarget} */
		var target = {
			parent: null,
			effect: null,
			effects: [],
			render_effects: [],
			block_effects: []
		};
		for (const root of root_effects) this.#traverse_effect_tree(root, target);
		if (!this.is_fork) this.#resolve();
		if (this.#blocking_pending > 0 || this.is_fork) {
			this.#defer_effects(target.effects);
			this.#defer_effects(target.render_effects);
			this.#defer_effects(target.block_effects);
		} else {
			previous_batch = this;
			current_batch = null;
			flush_queued_effects(target.render_effects);
			flush_queued_effects(target.effects);
			previous_batch = null;
			this.#deferred?.resolve();
		}
		batch_values = null;
	}
	/**
	* Traverse the effect tree, executing effects or stashing
	* them for later execution as appropriate
	* @param {Effect} root
	* @param {EffectTarget} target
	*/
	#traverse_effect_tree(root, target) {
		root.f ^= CLEAN;
		var effect$1 = root.first;
		while (effect$1 !== null) {
			var flags$1 = effect$1.f;
			var is_branch = (flags$1 & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
			var skip = is_branch && (flags$1 & CLEAN) !== 0 || (flags$1 & INERT) !== 0 || this.skipped_effects.has(effect$1);
			if ((effect$1.f & BOUNDARY_EFFECT) !== 0 && effect$1.b?.is_pending()) target = {
				parent: target,
				effect: effect$1,
				effects: [],
				render_effects: [],
				block_effects: []
			};
			if (!skip && effect$1.fn !== null) {
				if (is_branch) effect$1.f ^= CLEAN;
				else if ((flags$1 & EFFECT) !== 0) target.effects.push(effect$1);
				else if (async_mode_flag && (flags$1 & RENDER_EFFECT) !== 0) target.render_effects.push(effect$1);
				else if (is_dirty(effect$1)) {
					if ((effect$1.f & BLOCK_EFFECT) !== 0) target.block_effects.push(effect$1);
					update_effect(effect$1);
				}
				var child$1 = effect$1.first;
				if (child$1 !== null) {
					effect$1 = child$1;
					continue;
				}
			}
			var parent = effect$1.parent;
			effect$1 = effect$1.next;
			while (effect$1 === null && parent !== null) {
				if (parent === target.effect) {
					this.#defer_effects(target.effects);
					this.#defer_effects(target.render_effects);
					this.#defer_effects(target.block_effects);
					target = target.parent;
				}
				effect$1 = parent.next;
				parent = parent.parent;
			}
		}
	}
	/**
	* @param {Effect[]} effects
	*/
	#defer_effects(effects) {
		for (const e of effects) {
			((e.f & DIRTY) !== 0 ? this.#dirty_effects : this.#maybe_dirty_effects).push(e);
			set_signal_status(e, CLEAN);
		}
	}
	/**
	* Associate a change to a given source with the current
	* batch, noting its previous and current values
	* @param {Source} source
	* @param {any} value
	*/
	capture(source$1, value) {
		if (!this.previous.has(source$1)) this.previous.set(source$1, value);
		if ((source$1.f & ERROR_VALUE) === 0) {
			this.current.set(source$1, source$1.v);
			batch_values?.set(source$1, source$1.v);
		}
	}
	activate() {
		current_batch = this;
		this.apply();
	}
	deactivate() {
		current_batch = null;
		batch_values = null;
	}
	flush() {
		this.activate();
		if (queued_root_effects.length > 0) {
			flush_effects();
			if (current_batch !== null && current_batch !== this) return;
		} else if (this.#pending === 0) this.process([]);
		this.deactivate();
	}
	discard() {
		for (const fn of this.#discard_callbacks) fn(this);
		this.#discard_callbacks.clear();
	}
	#resolve() {
		if (this.#blocking_pending === 0) {
			for (const fn of this.#commit_callbacks) fn();
			this.#commit_callbacks.clear();
		}
		if (this.#pending === 0) this.#commit();
	}
	#commit() {
		if (batches.size > 1) {
			this.previous.clear();
			var previous_batch_values = batch_values;
			var is_earlier = true;
			/** @type {EffectTarget} */
			var dummy_target = {
				parent: null,
				effect: null,
				effects: [],
				render_effects: [],
				block_effects: []
			};
			for (const batch of batches) {
				if (batch === this) {
					is_earlier = false;
					continue;
				}
				/** @type {Source[]} */
				const sources = [];
				for (const [source$1, value] of this.current) {
					if (batch.current.has(source$1)) if (is_earlier && value !== batch.current.get(source$1)) batch.current.set(source$1, value);
					else continue;
					sources.push(source$1);
				}
				if (sources.length === 0) continue;
				const others = [...batch.current.keys()].filter((s) => !this.current.has(s));
				if (others.length > 0) {
					/** @type {Set<Value>} */
					const marked = /* @__PURE__ */ new Set();
					/** @type {Map<Reaction, boolean>} */
					const checked = /* @__PURE__ */ new Map();
					for (const source$1 of sources) mark_effects(source$1, others, marked, checked);
					if (queued_root_effects.length > 0) {
						current_batch = batch;
						batch.apply();
						for (const root of queued_root_effects) batch.#traverse_effect_tree(root, dummy_target);
						queued_root_effects = [];
						batch.deactivate();
					}
				}
			}
			current_batch = null;
			batch_values = previous_batch_values;
		}
		this.committed = true;
		batches.delete(this);
	}
	/**
	*
	* @param {boolean} blocking
	*/
	increment(blocking) {
		this.#pending += 1;
		if (blocking) this.#blocking_pending += 1;
	}
	/**
	*
	* @param {boolean} blocking
	*/
	decrement(blocking) {
		this.#pending -= 1;
		if (blocking) this.#blocking_pending -= 1;
		this.revive();
	}
	revive() {
		for (const e of this.#dirty_effects) {
			set_signal_status(e, DIRTY);
			schedule_effect(e);
		}
		for (const e of this.#maybe_dirty_effects) {
			set_signal_status(e, MAYBE_DIRTY);
			schedule_effect(e);
		}
		this.#dirty_effects = [];
		this.#maybe_dirty_effects = [];
		this.flush();
	}
	/** @param {() => void} fn */
	oncommit(fn) {
		this.#commit_callbacks.add(fn);
	}
	/** @param {(batch: Batch) => void} fn */
	ondiscard(fn) {
		this.#discard_callbacks.add(fn);
	}
	settled() {
		return (this.#deferred ??= deferred()).promise;
	}
	static ensure() {
		if (current_batch === null) {
			const batch = current_batch = new Batch();
			batches.add(current_batch);
			if (!is_flushing_sync) Batch.enqueue(() => {
				if (current_batch !== batch) return;
				batch.flush();
			});
		}
		return current_batch;
	}
	/** @param {() => void} task */
	static enqueue(task) {
		queue_micro_task(task);
	}
	apply() {
		if (!async_mode_flag || !this.is_fork && batches.size === 1) return;
		batch_values = new Map(this.current);
		for (const batch of batches) {
			if (batch === this) continue;
			for (const [source$1, previous] of batch.previous) if (!batch_values.has(source$1)) batch_values.set(source$1, previous);
		}
	}
};
/**
* Synchronously flush any pending updates.
* Returns void if no callback is provided, otherwise returns the result of calling the callback.
* @template [T=void]
* @param {(() => T) | undefined} [fn]
* @returns {T}
*/
function flushSync(fn) {
	if (async_mode_flag && active_effect !== null) flush_sync_in_effect();
	var was_flushing_sync = is_flushing_sync;
	is_flushing_sync = true;
	try {
		var result;
		if (fn) {
			if (current_batch !== null) flush_effects();
			result = fn();
		}
		while (true) {
			flush_tasks();
			if (queued_root_effects.length === 0) {
				current_batch?.flush();
				if (queued_root_effects.length === 0) {
					last_scheduled_effect = null;
					return result;
				}
			}
			flush_effects();
		}
	} finally {
		is_flushing_sync = was_flushing_sync;
	}
}
function flush_effects() {
	var was_updating_effect = is_updating_effect;
	is_flushing = true;
	try {
		var flush_count = 0;
		set_is_updating_effect(true);
		while (queued_root_effects.length > 0) {
			var batch = Batch.ensure();
			if (flush_count++ > 1e3) {
				if (true_default) {
					var updates = /* @__PURE__ */ new Map();
					for (const source$1 of batch.current.keys()) for (const [stack$1, update$1] of source$1.updated ?? []) {
						var entry = updates.get(stack$1);
						if (!entry) {
							entry = {
								error: update$1.error,
								count: 0
							};
							updates.set(stack$1, entry);
						}
						entry.count += update$1.count;
					}
					for (const update$1 of updates.values()) console.error(update$1.error);
				}
				infinite_loop_guard();
			}
			batch.process(queued_root_effects);
			old_values.clear();
		}
	} finally {
		is_flushing = false;
		set_is_updating_effect(was_updating_effect);
		last_scheduled_effect = null;
	}
}
function infinite_loop_guard() {
	try {
		effect_update_depth_exceeded();
	} catch (error) {
		if (true_default) define_property(error, "stack", { value: "" });
		invoke_error_boundary(error, last_scheduled_effect);
	}
}
/** @type {Set<Effect> | null} */
let eager_block_effects = null;
/**
* @param {Array<Effect>} effects
* @returns {void}
*/
function flush_queued_effects(effects) {
	var length = effects.length;
	if (length === 0) return;
	var i = 0;
	while (i < length) {
		var effect$1 = effects[i++];
		if ((effect$1.f & (DESTROYED | INERT)) === 0 && is_dirty(effect$1)) {
			eager_block_effects = /* @__PURE__ */ new Set();
			update_effect(effect$1);
			if (effect$1.deps === null && effect$1.first === null && effect$1.nodes_start === null) if (effect$1.teardown === null && effect$1.ac === null) unlink_effect(effect$1);
			else effect$1.fn = null;
			if (eager_block_effects?.size > 0) {
				old_values.clear();
				for (const e of eager_block_effects) {
					if ((e.f & (DESTROYED | INERT)) !== 0) continue;
					/** @type {Effect[]} */
					const ordered_effects = [e];
					let ancestor = e.parent;
					while (ancestor !== null) {
						if (eager_block_effects.has(ancestor)) {
							eager_block_effects.delete(ancestor);
							ordered_effects.push(ancestor);
						}
						ancestor = ancestor.parent;
					}
					for (let j = ordered_effects.length - 1; j >= 0; j--) {
						const e$1 = ordered_effects[j];
						if ((e$1.f & (DESTROYED | INERT)) !== 0) continue;
						update_effect(e$1);
					}
				}
				eager_block_effects.clear();
			}
		}
	}
	eager_block_effects = null;
}
/**
* This is similar to `mark_reactions`, but it only marks async/block effects
* depending on `value` and at least one of the other `sources`, so that
* these effects can re-run after another batch has been committed
* @param {Value} value
* @param {Source[]} sources
* @param {Set<Value>} marked
* @param {Map<Reaction, boolean>} checked
*/
function mark_effects(value, sources, marked, checked) {
	if (marked.has(value)) return;
	marked.add(value);
	if (value.reactions !== null) for (const reaction of value.reactions) {
		const flags$1 = reaction.f;
		if ((flags$1 & DERIVED) !== 0) mark_effects(reaction, sources, marked, checked);
		else if ((flags$1 & (ASYNC | BLOCK_EFFECT)) !== 0 && (flags$1 & DIRTY) === 0 && depends_on(reaction, sources, checked)) {
			set_signal_status(reaction, DIRTY);
			schedule_effect(reaction);
		}
	}
}
/**
* When committing a fork, we need to trigger eager effects so that
* any `$state.eager(...)` expressions update immediately. This
* function allows us to discover them
* @param {Value} value
* @param {Set<Effect>} effects
*/
function mark_eager_effects(value, effects) {
	if (value.reactions === null) return;
	for (const reaction of value.reactions) {
		const flags$1 = reaction.f;
		if ((flags$1 & DERIVED) !== 0) mark_eager_effects(reaction, effects);
		else if ((flags$1 & EAGER_EFFECT) !== 0) {
			set_signal_status(reaction, DIRTY);
			effects.add(reaction);
		}
	}
}
/**
* @param {Reaction} reaction
* @param {Source[]} sources
* @param {Map<Reaction, boolean>} checked
*/
function depends_on(reaction, sources, checked) {
	const depends = checked.get(reaction);
	if (depends !== void 0) return depends;
	if (reaction.deps !== null) for (const dep of reaction.deps) {
		if (sources.includes(dep)) return true;
		if ((dep.f & DERIVED) !== 0 && depends_on(dep, sources, checked)) {
			checked.set(dep, true);
			return true;
		}
	}
	checked.set(reaction, false);
	return false;
}
/**
* @param {Effect} signal
* @returns {void}
*/
function schedule_effect(signal) {
	var effect$1 = last_scheduled_effect = signal;
	while (effect$1.parent !== null) {
		effect$1 = effect$1.parent;
		var flags$1 = effect$1.f;
		if (is_flushing && effect$1 === active_effect && (flags$1 & BLOCK_EFFECT) !== 0 && (flags$1 & HEAD_EFFECT) === 0) return;
		if ((flags$1 & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
			if ((flags$1 & CLEAN) === 0) return;
			effect$1.f ^= CLEAN;
		}
	}
	queued_root_effects.push(effect$1);
}
/** @type {Source<number>[]} */
var eager_versions = [];
function eager_flush() {
	try {
		flushSync(() => {
			for (const version of eager_versions) update(version);
		});
	} finally {
		eager_versions = [];
	}
}
/**
* Implementation of `$state.eager(fn())`
* @template T
* @param {() => T} fn
* @returns {T}
*/
function eager(fn) {
	var version = source(0);
	var initial = true;
	var value = void 0;
	get(version);
	eager_effect(() => {
		if (initial) {
			var previous_batch_values = batch_values;
			try {
				batch_values = null;
				value = fn();
			} finally {
				batch_values = previous_batch_values;
			}
			return;
		}
		if (eager_versions.length === 0) queue_micro_task(eager_flush);
		eager_versions.push(version);
	});
	initial = false;
	return value;
}
/**
* Creates a 'fork', in which state changes are evaluated but not applied to the DOM.
* This is useful for speculatively loading data (for example) when you suspect that
* the user is about to take some action.
*
* Frameworks like SvelteKit can use this to preload data when the user touches or
* hovers over a link, making any subsequent navigation feel instantaneous.
*
* The `fn` parameter is a synchronous function that modifies some state. The
* state changes will be reverted after the fork is initialised, then reapplied
* if and when the fork is eventually committed.
*
* When it becomes clear that a fork will _not_ be committed (e.g. because the
* user navigated elsewhere), it must be discarded to avoid leaking memory.
*
* @param {() => void} fn
* @returns {Fork}
* @since 5.42
*/
function fork(fn) {
	if (!async_mode_flag) experimental_async_fork();
	if (current_batch !== null) fork_timing();
	var batch = Batch.ensure();
	batch.is_fork = true;
	var committed = false;
	var settled$1 = batch.settled();
	flushSync(fn);
	for (var [source$1, value] of batch.previous) source$1.v = value;
	return {
		commit: async () => {
			if (committed) {
				await settled$1;
				return;
			}
			if (!batches.has(batch)) fork_discarded();
			committed = true;
			batch.is_fork = false;
			for (var [source$2, value$1] of batch.current) source$2.v = value$1;
			flushSync(() => {
				/** @type {Set<Effect>} */
				var eager_effects$1 = /* @__PURE__ */ new Set();
				for (var source$3 of batch.current.keys()) mark_eager_effects(source$3, eager_effects$1);
				set_eager_effects(eager_effects$1);
				flush_eager_effects();
			});
			batch.revive();
			await settled$1;
		},
		discard: () => {
			if (!committed && batches.has(batch)) {
				batches.delete(batch);
				batch.discard();
			}
		}
	};
}

//#endregion
//#region node_modules/svelte/src/reactivity/create-subscriber.js
/**
* Returns a `subscribe` function that integrates external event-based systems with Svelte's reactivity.
* It's particularly useful for integrating with web APIs like `MediaQuery`, `IntersectionObserver`, or `WebSocket`.
*
* If `subscribe` is called inside an effect (including indirectly, for example inside a getter),
* the `start` callback will be called with an `update` function. Whenever `update` is called, the effect re-runs.
*
* If `start` returns a cleanup function, it will be called when the effect is destroyed.
*
* If `subscribe` is called in multiple effects, `start` will only be called once as long as the effects
* are active, and the returned teardown function will only be called when all effects are destroyed.
*
* It's best understood with an example. Here's an implementation of [`MediaQuery`](https://svelte.dev/docs/svelte/svelte-reactivity#MediaQuery):
*
* ```js
* import { createSubscriber } from 'svelte/reactivity';
* import { on } from 'svelte/events';
*
* export class MediaQuery {
* 	#query;
* 	#subscribe;
*
* 	constructor(query) {
* 		this.#query = window.matchMedia(`(${query})`);
*
* 		this.#subscribe = createSubscriber((update) => {
* 			// when the `change` event occurs, re-run any effects that read `this.current`
* 			const off = on(this.#query, 'change', update);
*
* 			// stop listening when all the effects are destroyed
* 			return () => off();
* 		});
* 	}
*
* 	get current() {
* 		// This makes the getter reactive, if read in an effect
* 		this.#subscribe();
*
* 		// Return the current state of the query, whether or not we're in an effect
* 		return this.#query.matches;
* 	}
* }
* ```
* @param {(update: () => void) => (() => void) | void} start
* @since 5.7.0
*/
function createSubscriber(start) {
	let subscribers = 0;
	let version = source(0);
	/** @type {(() => void) | void} */
	let stop;
	if (true_default) tag(version, "createSubscriber version");
	return () => {
		if (effect_tracking()) {
			get(version);
			render_effect(() => {
				if (subscribers === 0) stop = untrack(() => start(() => increment(version)));
				subscribers += 1;
				return () => {
					queue_micro_task(() => {
						subscribers -= 1;
						if (subscribers === 0) {
							stop?.();
							stop = void 0;
							increment(version);
						}
					});
				};
			});
		}
	};
}

//#endregion
//#region node_modules/svelte/src/internal/client/dom/blocks/boundary.js
/** @import { Effect, Source, TemplateNode, } from '#client' */
/**
* @typedef {{
* 	 onerror?: (error: unknown, reset: () => void) => void;
*   failed?: (anchor: Node, error: () => unknown, reset: () => () => void) => void;
*   pending?: (anchor: Node) => void;
* }} BoundaryProps
*/
var flags = EFFECT_TRANSPARENT | EFFECT_PRESERVED | BOUNDARY_EFFECT;
/**
* @param {TemplateNode} node
* @param {BoundaryProps} props
* @param {((anchor: Node) => void)} children
* @returns {void}
*/
function boundary(node, props, children) {
	new Boundary(node, props, children);
}
var Boundary = class {
	/** @type {Boundary | null} */
	parent;
	#pending = false;
	/** @type {TemplateNode} */
	#anchor;
	/** @type {TemplateNode | null} */
	#hydrate_open = hydrating ? hydrate_node : null;
	/** @type {BoundaryProps} */
	#props;
	/** @type {((anchor: Node) => void)} */
	#children;
	/** @type {Effect} */
	#effect;
	/** @type {Effect | null} */
	#main_effect = null;
	/** @type {Effect | null} */
	#pending_effect = null;
	/** @type {Effect | null} */
	#failed_effect = null;
	/** @type {DocumentFragment | null} */
	#offscreen_fragment = null;
	/** @type {TemplateNode | null} */
	#pending_anchor = null;
	#local_pending_count = 0;
	#pending_count = 0;
	#is_creating_fallback = false;
	/**
	* A source containing the number of pending async deriveds/expressions.
	* Only created if `$effect.pending()` is used inside the boundary,
	* otherwise updating the source results in needless `Batch.ensure()`
	* calls followed by no-op flushes
	* @type {Source<number> | null}
	*/
	#effect_pending = null;
	#effect_pending_subscriber = createSubscriber(() => {
		this.#effect_pending = source(this.#local_pending_count);
		if (true_default) tag(this.#effect_pending, "$effect.pending()");
		return () => {
			this.#effect_pending = null;
		};
	});
	/**
	* @param {TemplateNode} node
	* @param {BoundaryProps} props
	* @param {((anchor: Node) => void)} children
	*/
	constructor(node, props, children) {
		this.#anchor = node;
		this.#props = props;
		this.#children = children;
		this.parent = active_effect.b;
		this.#pending = !!this.#props.pending;
		this.#effect = block(() => {
			/** @type {Effect} */ active_effect.b = this;
			if (hydrating) {
				const comment = this.#hydrate_open;
				hydrate_next();
				if (comment.nodeType === COMMENT_NODE && comment.data === HYDRATION_START_ELSE) this.#hydrate_pending_content();
				else this.#hydrate_resolved_content();
			} else {
				var anchor = this.#get_anchor();
				try {
					this.#main_effect = branch(() => children(anchor));
				} catch (error) {
					this.error(error);
				}
				if (this.#pending_count > 0) this.#show_pending_snippet();
				else this.#pending = false;
			}
			return () => {
				this.#pending_anchor?.remove();
			};
		}, flags);
		if (hydrating) this.#anchor = hydrate_node;
	}
	#hydrate_resolved_content() {
		try {
			this.#main_effect = branch(() => this.#children(this.#anchor));
		} catch (error) {
			this.error(error);
		}
		this.#pending = false;
	}
	#hydrate_pending_content() {
		const pending$1 = this.#props.pending;
		if (!pending$1) return;
		this.#pending_effect = branch(() => pending$1(this.#anchor));
		Batch.enqueue(() => {
			var anchor = this.#get_anchor();
			this.#main_effect = this.#run(() => {
				Batch.ensure();
				return branch(() => this.#children(anchor));
			});
			if (this.#pending_count > 0) this.#show_pending_snippet();
			else {
				pause_effect(this.#pending_effect, () => {
					this.#pending_effect = null;
				});
				this.#pending = false;
			}
		});
	}
	#get_anchor() {
		var anchor = this.#anchor;
		if (this.#pending) {
			this.#pending_anchor = create_text();
			this.#anchor.before(this.#pending_anchor);
			anchor = this.#pending_anchor;
		}
		return anchor;
	}
	/**
	* Returns `true` if the effect exists inside a boundary whose pending snippet is shown
	* @returns {boolean}
	*/
	is_pending() {
		return this.#pending || !!this.parent && this.parent.is_pending();
	}
	has_pending_snippet() {
		return !!this.#props.pending;
	}
	/**
	* @param {() => Effect | null} fn
	*/
	#run(fn) {
		var previous_effect = active_effect;
		var previous_reaction = active_reaction;
		var previous_ctx = component_context;
		set_active_effect(this.#effect);
		set_active_reaction(this.#effect);
		set_component_context(this.#effect.ctx);
		try {
			return fn();
		} catch (e) {
			handle_error(e);
			return null;
		} finally {
			set_active_effect(previous_effect);
			set_active_reaction(previous_reaction);
			set_component_context(previous_ctx);
		}
	}
	#show_pending_snippet() {
		const pending$1 = this.#props.pending;
		if (this.#main_effect !== null) {
			this.#offscreen_fragment = document.createDocumentFragment();
			this.#offscreen_fragment.append(this.#pending_anchor);
			move_effect(this.#main_effect, this.#offscreen_fragment);
		}
		if (this.#pending_effect === null) this.#pending_effect = branch(() => pending$1(this.#anchor));
	}
	/**
	* Updates the pending count associated with the currently visible pending snippet,
	* if any, such that we can replace the snippet with content once work is done
	* @param {1 | -1} d
	*/
	#update_pending_count(d) {
		if (!this.has_pending_snippet()) {
			if (this.parent) this.parent.#update_pending_count(d);
			return;
		}
		this.#pending_count += d;
		if (this.#pending_count === 0) {
			this.#pending = false;
			if (this.#pending_effect) pause_effect(this.#pending_effect, () => {
				this.#pending_effect = null;
			});
			if (this.#offscreen_fragment) {
				this.#anchor.before(this.#offscreen_fragment);
				this.#offscreen_fragment = null;
			}
		}
	}
	/**
	* Update the source that powers `$effect.pending()` inside this boundary,
	* and controls when the current `pending` snippet (if any) is removed.
	* Do not call from inside the class
	* @param {1 | -1} d
	*/
	update_pending_count(d) {
		this.#update_pending_count(d);
		this.#local_pending_count += d;
		if (this.#effect_pending) internal_set(this.#effect_pending, this.#local_pending_count);
	}
	get_effect_pending() {
		this.#effect_pending_subscriber();
		return get(this.#effect_pending);
	}
	/** @param {unknown} error */
	error(error) {
		var onerror = this.#props.onerror;
		let failed = this.#props.failed;
		if (this.#is_creating_fallback || !onerror && !failed) throw error;
		if (this.#main_effect) {
			destroy_effect(this.#main_effect);
			this.#main_effect = null;
		}
		if (this.#pending_effect) {
			destroy_effect(this.#pending_effect);
			this.#pending_effect = null;
		}
		if (this.#failed_effect) {
			destroy_effect(this.#failed_effect);
			this.#failed_effect = null;
		}
		if (hydrating) {
			set_hydrate_node(this.#hydrate_open);
			next();
			set_hydrate_node(skip_nodes());
		}
		var did_reset = false;
		var calling_on_error = false;
		const reset$1 = () => {
			if (did_reset) {
				svelte_boundary_reset_noop();
				return;
			}
			did_reset = true;
			if (calling_on_error) svelte_boundary_reset_onerror();
			Batch.ensure();
			this.#local_pending_count = 0;
			if (this.#failed_effect !== null) pause_effect(this.#failed_effect, () => {
				this.#failed_effect = null;
			});
			this.#pending = this.has_pending_snippet();
			this.#main_effect = this.#run(() => {
				this.#is_creating_fallback = false;
				return branch(() => this.#children(this.#anchor));
			});
			if (this.#pending_count > 0) this.#show_pending_snippet();
			else this.#pending = false;
		};
		var previous_reaction = active_reaction;
		try {
			set_active_reaction(null);
			calling_on_error = true;
			onerror?.(error, reset$1);
			calling_on_error = false;
		} catch (error$1) {
			invoke_error_boundary(error$1, this.#effect && this.#effect.parent);
		} finally {
			set_active_reaction(previous_reaction);
		}
		if (failed) queue_micro_task(() => {
			this.#failed_effect = this.#run(() => {
				Batch.ensure();
				this.#is_creating_fallback = true;
				try {
					return branch(() => {
						failed(this.#anchor, () => error, () => reset$1);
					});
				} catch (error$1) {
					invoke_error_boundary(error$1, this.#effect.parent);
					return null;
				} finally {
					this.#is_creating_fallback = false;
				}
			});
		});
	}
};
function get_boundary() {
	return active_effect.b;
}
function pending() {
	if (active_effect === null) effect_pending_outside_reaction();
	var boundary$1 = active_effect.b;
	if (boundary$1 === null) return 0;
	return boundary$1.get_effect_pending();
}

//#endregion
//#region node_modules/svelte/src/internal/client/reactivity/async.js
/** @import { Effect, TemplateNode, Value } from '#client' */
/**
* @param {Array<Promise<void>>} blockers
* @param {Array<() => any>} sync
* @param {Array<() => Promise<any>>} async
* @param {(values: Value[]) => any} fn
*/
function flatten(blockers, sync, async, fn) {
	const d = is_runes() ? derived : derived_safe_equal;
	if (async.length === 0 && blockers.length === 0) {
		fn(sync.map(d));
		return;
	}
	var batch = current_batch;
	var parent = active_effect;
	var restore = capture();
	function run$2() {
		Promise.all(async.map((expression) => /* @__PURE__ */ async_derived(expression))).then((result) => {
			restore();
			try {
				fn([...sync.map(d), ...result]);
			} catch (error) {
				if ((parent.f & DESTROYED) === 0) invoke_error_boundary(error, parent);
			}
			batch?.deactivate();
			unset_context();
		}).catch((error) => {
			invoke_error_boundary(error, parent);
		});
	}
	if (blockers.length > 0) Promise.all(blockers).then(() => {
		restore();
		try {
			return run$2();
		} finally {
			batch?.deactivate();
			unset_context();
		}
	});
	else run$2();
}
/**
* @param {Array<Promise<void>>} blockers
* @param {(values: Value[]) => any} fn
*/
function run_after_blockers(blockers, fn) {
	flatten(blockers, [], [], fn);
}
/**
* Captures the current effect context so that we can restore it after
* some asynchronous work has happened (so that e.g. `await a + b`
* causes `b` to be registered as a dependency).
*/
function capture() {
	var previous_effect = active_effect;
	var previous_reaction = active_reaction;
	var previous_component_context = component_context;
	var previous_batch$1 = current_batch;
	if (true_default) var previous_dev_stack = dev_stack;
	return function restore(activate_batch = true) {
		set_active_effect(previous_effect);
		set_active_reaction(previous_reaction);
		set_component_context(previous_component_context);
		if (activate_batch) previous_batch$1?.activate();
		if (true_default) {
			set_from_async_derived(null);
			set_dev_stack(previous_dev_stack);
		}
	};
}
/**
* Wraps an `await` expression in such a way that the effect context that was
* active before the expression evaluated can be reapplied afterwards —
* `await a + b` becomes `(await $.save(a))() + b`
* @template T
* @param {Promise<T>} promise
* @returns {Promise<() => T>}
*/
async function save(promise) {
	var restore = capture();
	var value = await promise;
	return () => {
		restore();
		return value;
	};
}
/**
* Reset `current_async_effect` after the `promise` resolves, so
* that we can emit `await_reactivity_loss` warnings
* @template T
* @param {Promise<T>} promise
* @returns {Promise<() => T>}
*/
async function track_reactivity_loss(promise) {
	var previous_async_effect = current_async_effect;
	var value = await promise;
	return () => {
		set_from_async_derived(previous_async_effect);
		return value;
	};
}
/**
* Used in `for await` loops in DEV, so
* that we can emit `await_reactivity_loss` warnings
* after each `async_iterator` result resolves and
* after the `async_iterator` return resolves (if it runs)
* @template T
* @template TReturn
* @param {Iterable<T> | AsyncIterable<T>} iterable
* @returns {AsyncGenerator<T, TReturn | undefined>}
*/
async function* for_await_track_reactivity_loss(iterable) {
	/** @type {AsyncIterator<T, TReturn>} */
	const iterator = iterable[Symbol.asyncIterator]?.() ?? iterable[Symbol.iterator]?.();
	if (iterator === void 0) throw new TypeError("value is not async iterable");
	/** Whether the completion of the iterator was "normal", meaning it wasn't ended via `break` or a similar method */
	let normal_completion = false;
	try {
		while (true) {
			const { done, value } = (await track_reactivity_loss(iterator.next()))();
			if (done) {
				normal_completion = true;
				break;
			}
			yield value;
		}
	} finally {
		if (normal_completion && iterator.return !== void 0) return (await track_reactivity_loss(iterator.return()))().value;
	}
}
function unset_context() {
	set_active_effect(null);
	set_active_reaction(null);
	set_component_context(null);
	if (true_default) {
		set_from_async_derived(null);
		set_dev_stack(null);
	}
}
/**
* @param {TemplateNode} anchor
* @param {(target: TemplateNode) => Promise<void>} fn
*/
async function async_body(anchor, fn) {
	var boundary$1 = get_boundary();
	var batch = current_batch;
	var blocking = !boundary$1.is_pending();
	boundary$1.update_pending_count(1);
	batch.increment(blocking);
	var active = active_effect;
	var was_hydrating = hydrating;
	var next_hydrate_node = void 0;
	if (was_hydrating) {
		hydrate_next();
		next_hydrate_node = skip_nodes(false);
	}
	try {
		var promise = fn(anchor);
	} finally {
		if (next_hydrate_node) {
			set_hydrate_node(next_hydrate_node);
			hydrate_next();
		}
	}
	try {
		await promise;
	} catch (error) {
		if (!aborted(active)) invoke_error_boundary(error, active);
	} finally {
		boundary$1.update_pending_count(-1);
		batch.decrement(blocking);
		unset_context();
	}
}
/**
* @param {Array<() => void | Promise<void>>} thunks
*/
function run(thunks) {
	const restore = capture();
	var boundary$1 = get_boundary();
	var batch = current_batch;
	var blocking = !boundary$1.is_pending();
	boundary$1.update_pending_count(1);
	batch.increment(blocking);
	var active = active_effect;
	/** @type {null | { error: any }} */
	var errored = null;
	/** @param {any} error */
	const handle_error$1 = (error) => {
		errored = { error };
		if (!aborted(active)) invoke_error_boundary(error, active);
	};
	var promise = Promise.resolve(thunks[0]()).catch(handle_error$1);
	var promises = [promise];
	for (const fn of thunks.slice(1)) {
		promise = promise.then(() => {
			if (errored) throw errored.error;
			if (aborted(active)) throw STALE_REACTION;
			try {
				restore();
				return fn();
			} finally {
				unset_context();
			}
		}).catch(handle_error$1).finally(() => {
			unset_context();
		});
		promises.push(promise);
	}
	promise.then(() => Promise.resolve()).finally(() => {
		boundary$1.update_pending_count(-1);
		batch.decrement(blocking);
	});
	return promises;
}

//#endregion
//#region node_modules/svelte/src/internal/client/reactivity/deriveds.js
/** @import { Derived, Effect, Source } from '#client' */
/** @import { Batch } from './batch.js'; */
/** @type {Effect | null} */
let current_async_effect = null;
/** @param {Effect | null} v */
function set_from_async_derived(v) {
	current_async_effect = v;
}
const recent_async_deriveds = /* @__PURE__ */ new Set();
/**
* @template V
* @param {() => V} fn
* @returns {Derived<V>}
*/
/* @__NO_SIDE_EFFECTS__ */
function derived(fn) {
	var flags$1 = DERIVED | DIRTY;
	var parent_derived = active_reaction !== null && (active_reaction.f & DERIVED) !== 0 ? active_reaction : null;
	if (active_effect !== null) active_effect.f |= EFFECT_PRESERVED;
	/** @type {Derived<V>} */
	const signal = {
		ctx: component_context,
		deps: null,
		effects: null,
		equals: equals$1,
		f: flags$1,
		fn,
		reactions: null,
		rv: 0,
		v: UNINITIALIZED,
		wv: 0,
		parent: parent_derived ?? active_effect,
		ac: null
	};
	if (true_default && tracing_mode_flag) signal.created = get_stack("created at");
	return signal;
}
/**
* @template V
* @param {() => V | Promise<V>} fn
* @param {string} [location] If provided, print a warning if the value is not read immediately after update
* @returns {Promise<Source<V>>}
*/
/* @__NO_SIDE_EFFECTS__ */
function async_derived(fn, location) {
	let parent = active_effect;
	if (parent === null) async_derived_orphan();
	var boundary$1 = parent.b;
	var promise = void 0;
	var signal = source(UNINITIALIZED);
	var should_suspend = !active_reaction;
	/** @type {Map<Batch, ReturnType<typeof deferred<V>>>} */
	var deferreds = /* @__PURE__ */ new Map();
	async_effect(() => {
		if (true_default) current_async_effect = active_effect;
		/** @type {ReturnType<typeof deferred<V>>} */
		var d = deferred();
		promise = d.promise;
		try {
			Promise.resolve(fn()).then(d.resolve, d.reject).then(() => {
				if (batch === current_batch && batch.committed) batch.deactivate();
				unset_context();
			});
		} catch (error) {
			d.reject(error);
			unset_context();
		}
		if (true_default) current_async_effect = null;
		var batch = current_batch;
		if (should_suspend) {
			var blocking = !boundary$1.is_pending();
			boundary$1.update_pending_count(1);
			batch.increment(blocking);
			deferreds.get(batch)?.reject(STALE_REACTION);
			deferreds.delete(batch);
			deferreds.set(batch, d);
		}
		/**
		* @param {any} value
		* @param {unknown} error
		*/
		const handler = (value, error = void 0) => {
			current_async_effect = null;
			batch.activate();
			if (error) {
				if (error !== STALE_REACTION) {
					signal.f |= ERROR_VALUE;
					internal_set(signal, error);
				}
			} else {
				if ((signal.f & ERROR_VALUE) !== 0) signal.f ^= ERROR_VALUE;
				internal_set(signal, value);
				for (const [b, d$1] of deferreds) {
					deferreds.delete(b);
					if (b === batch) break;
					d$1.reject(STALE_REACTION);
				}
				if (true_default && location !== void 0) {
					recent_async_deriveds.add(signal);
					setTimeout(() => {
						if (recent_async_deriveds.has(signal)) {
							await_waterfall(signal.label, location);
							recent_async_deriveds.delete(signal);
						}
					});
				}
			}
			if (should_suspend) {
				boundary$1.update_pending_count(-1);
				batch.decrement(blocking);
			}
		};
		d.promise.then(handler, (e) => handler(null, e || "unknown"));
	});
	teardown(() => {
		for (const d of deferreds.values()) d.reject(STALE_REACTION);
	});
	if (true_default) signal.f |= ASYNC;
	return new Promise((fulfil) => {
		/** @param {Promise<V>} p */
		function next$1(p) {
			function go() {
				if (p === promise) fulfil(signal);
				else next$1(promise);
			}
			p.then(go, go);
		}
		next$1(promise);
	});
}
/**
* @template V
* @param {() => V} fn
* @returns {Derived<V>}
*/
/* @__NO_SIDE_EFFECTS__ */
function user_derived(fn) {
	const d = /* @__PURE__ */ derived(fn);
	if (!async_mode_flag) push_reaction_value(d);
	return d;
}
/**
* @template V
* @param {() => V} fn
* @returns {Derived<V>}
*/
/* @__NO_SIDE_EFFECTS__ */
function derived_safe_equal(fn) {
	const signal = /* @__PURE__ */ derived(fn);
	signal.equals = safe_equals;
	return signal;
}
/**
* @param {Derived} derived
* @returns {void}
*/
function destroy_derived_effects(derived$1) {
	var effects = derived$1.effects;
	if (effects !== null) {
		derived$1.effects = null;
		for (var i = 0; i < effects.length; i += 1) destroy_effect(effects[i]);
	}
}
/**
* The currently updating deriveds, used to detect infinite recursion
* in dev mode and provide a nicer error than 'too much recursion'
* @type {Derived[]}
*/
var stack = [];
/**
* @param {Derived} derived
* @returns {Effect | null}
*/
function get_derived_parent_effect(derived$1) {
	var parent = derived$1.parent;
	while (parent !== null) {
		if ((parent.f & DERIVED) === 0) return parent;
		parent = parent.parent;
	}
	return null;
}
/**
* @template T
* @param {Derived} derived
* @returns {T}
*/
function execute_derived(derived$1) {
	var value;
	var prev_active_effect = active_effect;
	set_active_effect(get_derived_parent_effect(derived$1));
	if (true_default) {
		let prev_eager_effects = eager_effects;
		set_eager_effects(/* @__PURE__ */ new Set());
		try {
			if (stack.includes(derived$1)) derived_references_self();
			stack.push(derived$1);
			derived$1.f &= ~WAS_MARKED;
			destroy_derived_effects(derived$1);
			value = update_reaction(derived$1);
		} finally {
			set_active_effect(prev_active_effect);
			set_eager_effects(prev_eager_effects);
			stack.pop();
		}
	} else try {
		derived$1.f &= ~WAS_MARKED;
		destroy_derived_effects(derived$1);
		value = update_reaction(derived$1);
	} finally {
		set_active_effect(prev_active_effect);
	}
	return value;
}
/**
* @param {Derived} derived
* @returns {void}
*/
function update_derived(derived$1) {
	var value = execute_derived(derived$1);
	if (!derived$1.equals(value)) {
		derived$1.v = value;
		derived$1.wv = increment_write_version();
	}
	if (is_destroying_effect) return;
	if (batch_values !== null) {
		if (effect_tracking()) batch_values.set(derived$1, derived$1.v);
	} else set_signal_status(derived$1, (derived$1.f & CONNECTED) === 0 ? MAYBE_DIRTY : CLEAN);
}

//#endregion
//#region node_modules/svelte/src/internal/client/reactivity/sources.js
/** @import { Derived, Effect, Source, Value } from '#client' */
/** @type {Set<any>} */
let eager_effects = /* @__PURE__ */ new Set();
/** @type {Map<Source, any>} */
const old_values = /* @__PURE__ */ new Map();
/**
* @param {Set<any>} v
*/
function set_eager_effects(v) {
	eager_effects = v;
}
var eager_effects_deferred = false;
function set_eager_effects_deferred() {
	eager_effects_deferred = true;
}
/**
* @template V
* @param {V} v
* @param {Error | null} [stack]
* @returns {Source<V>}
*/
function source(v, stack$1) {
	/** @type {Value} */
	var signal = {
		f: 0,
		v,
		reactions: null,
		equals: equals$1,
		rv: 0,
		wv: 0
	};
	if (true_default && tracing_mode_flag) {
		signal.created = stack$1 ?? get_stack("created at");
		signal.updated = null;
		signal.set_during_effect = false;
		signal.trace = null;
	}
	return signal;
}
/**
* @template V
* @param {V} v
* @param {Error | null} [stack]
*/
/* @__NO_SIDE_EFFECTS__ */
function state(v, stack$1) {
	const s = source(v, stack$1);
	push_reaction_value(s);
	return s;
}
/**
* @template V
* @param {V} initial_value
* @param {boolean} [immutable]
* @returns {Source<V>}
*/
/* @__NO_SIDE_EFFECTS__ */
function mutable_source(initial_value, immutable = false, trackable = true) {
	const s = source(initial_value);
	if (!immutable) s.equals = safe_equals;
	if (legacy_mode_flag && trackable && component_context !== null && component_context.l !== null) (component_context.l.s ??= []).push(s);
	return s;
}
/**
* @template V
* @param {Value<V>} source
* @param {V} value
*/
function mutate(source$1, value) {
	set(source$1, untrack(() => get(source$1)));
	return value;
}
/**
* @template V
* @param {Source<V>} source
* @param {V} value
* @param {boolean} [should_proxy]
* @returns {V}
*/
function set(source$1, value, should_proxy = false) {
	if (active_reaction !== null && (!untracking || (active_reaction.f & EAGER_EFFECT) !== 0) && is_runes() && (active_reaction.f & (DERIVED | BLOCK_EFFECT | ASYNC | EAGER_EFFECT)) !== 0 && !current_sources?.includes(source$1)) state_unsafe_mutation();
	let new_value = should_proxy ? proxy(value) : value;
	if (true_default) tag_proxy(new_value, source$1.label);
	return internal_set(source$1, new_value);
}
/**
* @template V
* @param {Source<V>} source
* @param {V} value
* @returns {V}
*/
function internal_set(source$1, value) {
	if (!source$1.equals(value)) {
		var old_value = source$1.v;
		if (is_destroying_effect) old_values.set(source$1, value);
		else old_values.set(source$1, old_value);
		source$1.v = value;
		var batch = Batch.ensure();
		batch.capture(source$1, old_value);
		if (true_default) {
			if (tracing_mode_flag || active_effect !== null) {
				const error = get_stack("updated at");
				if (error !== null) {
					source$1.updated ??= /* @__PURE__ */ new Map();
					let entry = source$1.updated.get(error.stack);
					if (!entry) {
						entry = {
							error,
							count: 0
						};
						source$1.updated.set(error.stack, entry);
					}
					entry.count++;
				}
			}
			if (active_effect !== null) source$1.set_during_effect = true;
		}
		if ((source$1.f & DERIVED) !== 0) {
			if ((source$1.f & DIRTY) !== 0) execute_derived(source$1);
			set_signal_status(source$1, (source$1.f & CONNECTED) !== 0 ? CLEAN : MAYBE_DIRTY);
		}
		source$1.wv = increment_write_version();
		mark_reactions(source$1, DIRTY);
		if (is_runes() && active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) if (untracked_writes === null) set_untracked_writes([source$1]);
		else untracked_writes.push(source$1);
		if (!batch.is_fork && eager_effects.size > 0 && !eager_effects_deferred) flush_eager_effects();
	}
	return value;
}
function flush_eager_effects() {
	eager_effects_deferred = false;
	const inspects = Array.from(eager_effects);
	for (const effect$1 of inspects) {
		if ((effect$1.f & CLEAN) !== 0) set_signal_status(effect$1, MAYBE_DIRTY);
		if (is_dirty(effect$1)) update_effect(effect$1);
	}
	eager_effects.clear();
}
/**
* @template {number | bigint} T
* @param {Source<T>} source
* @param {1 | -1} [d]
* @returns {T}
*/
function update(source$1, d = 1) {
	var value = get(source$1);
	var result = d === 1 ? value++ : value--;
	set(source$1, value);
	return result;
}
/**
* @template {number | bigint} T
* @param {Source<T>} source
* @param {1 | -1} [d]
* @returns {T}
*/
function update_pre(source$1, d = 1) {
	var value = get(source$1);
	return set(source$1, d === 1 ? ++value : --value);
}
/**
* Silently (without using `get`) increment a source
* @param {Source<number>} source
*/
function increment(source$1) {
	set(source$1, source$1.v + 1);
}
/**
* @param {Value} signal
* @param {number} status should be DIRTY or MAYBE_DIRTY
* @returns {void}
*/
function mark_reactions(signal, status) {
	var reactions = signal.reactions;
	if (reactions === null) return;
	var runes = is_runes();
	var length = reactions.length;
	for (var i = 0; i < length; i++) {
		var reaction = reactions[i];
		var flags$1 = reaction.f;
		if (!runes && reaction === active_effect) continue;
		if (true_default && (flags$1 & EAGER_EFFECT) !== 0) {
			eager_effects.add(reaction);
			continue;
		}
		var not_dirty = (flags$1 & DIRTY) === 0;
		if (not_dirty) set_signal_status(reaction, status);
		if ((flags$1 & DERIVED) !== 0) {
			var derived$1 = reaction;
			batch_values?.delete(derived$1);
			if ((flags$1 & WAS_MARKED) === 0) {
				if (flags$1 & CONNECTED) reaction.f |= WAS_MARKED;
				mark_reactions(derived$1, MAYBE_DIRTY);
			}
		} else if (not_dirty) {
			if ((flags$1 & BLOCK_EFFECT) !== 0) {
				if (eager_block_effects !== null) eager_block_effects.add(reaction);
			}
			schedule_effect(reaction);
		}
	}
}

//#endregion
//#region node_modules/svelte/src/internal/client/proxy.js
/** @import { Source } from '#client' */
var regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
/**
* @template T
* @param {T} value
* @returns {T}
*/
function proxy(value) {
	if (typeof value !== "object" || value === null || STATE_SYMBOL in value) return value;
	const prototype = get_prototype_of(value);
	if (prototype !== object_prototype && prototype !== array_prototype) return value;
	/** @type {Map<any, Source<any>>} */
	var sources = /* @__PURE__ */ new Map();
	var is_proxied_array = is_array(value);
	var version = /* @__PURE__ */ state(0);
	var stack$1 = true_default && tracing_mode_flag ? get_stack("created at") : null;
	var parent_version = update_version;
	/**
	* Executes the proxy in the context of the reaction it was originally created in, if any
	* @template T
	* @param {() => T} fn
	*/
	var with_parent = (fn) => {
		if (update_version === parent_version) return fn();
		var reaction = active_reaction;
		var version$1 = update_version;
		set_active_reaction(null);
		set_update_version(parent_version);
		var result = fn();
		set_active_reaction(reaction);
		set_update_version(version$1);
		return result;
	};
	if (is_proxied_array) {
		sources.set("length", /* @__PURE__ */ state(
			/** @type {any[]} */
			value.length,
			stack$1
		));
		if (true_default) value = inspectable_array(value);
	}
	/** Used in dev for $inspect.trace() */
	var path = "";
	let updating = false;
	/** @param {string} new_path */
	function update_path(new_path) {
		if (updating) return;
		updating = true;
		path = new_path;
		tag(version, `${path} version`);
		for (const [prop, source$1] of sources) tag(source$1, get_label(path, prop));
		updating = false;
	}
	return new Proxy(value, {
		defineProperty(_, prop, descriptor) {
			if (!("value" in descriptor) || descriptor.configurable === false || descriptor.enumerable === false || descriptor.writable === false) state_descriptors_fixed();
			var s = sources.get(prop);
			if (s === void 0) s = with_parent(() => {
				var s$1 = /* @__PURE__ */ state(descriptor.value, stack$1);
				sources.set(prop, s$1);
				if (true_default && typeof prop === "string") tag(s$1, get_label(path, prop));
				return s$1;
			});
			else set(s, descriptor.value, true);
			return true;
		},
		deleteProperty(target, prop) {
			var s = sources.get(prop);
			if (s === void 0) {
				if (prop in target) {
					const s$1 = with_parent(() => /* @__PURE__ */ state(UNINITIALIZED, stack$1));
					sources.set(prop, s$1);
					increment(version);
					if (true_default) tag(s$1, get_label(path, prop));
				}
			} else {
				set(s, UNINITIALIZED);
				increment(version);
			}
			return true;
		},
		get(target, prop, receiver) {
			if (prop === STATE_SYMBOL) return value;
			if (true_default && prop === PROXY_PATH_SYMBOL) return update_path;
			var s = sources.get(prop);
			var exists = prop in target;
			if (s === void 0 && (!exists || get_descriptor(target, prop)?.writable)) {
				s = with_parent(() => {
					var s$1 = /* @__PURE__ */ state(proxy(exists ? target[prop] : UNINITIALIZED), stack$1);
					if (true_default) tag(s$1, get_label(path, prop));
					return s$1;
				});
				sources.set(prop, s);
			}
			if (s !== void 0) {
				var v = get(s);
				return v === UNINITIALIZED ? void 0 : v;
			}
			return Reflect.get(target, prop, receiver);
		},
		getOwnPropertyDescriptor(target, prop) {
			var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);
			if (descriptor && "value" in descriptor) {
				var s = sources.get(prop);
				if (s) descriptor.value = get(s);
			} else if (descriptor === void 0) {
				var source$1 = sources.get(prop);
				var value$1 = source$1?.v;
				if (source$1 !== void 0 && value$1 !== UNINITIALIZED) return {
					enumerable: true,
					configurable: true,
					value: value$1,
					writable: true
				};
			}
			return descriptor;
		},
		has(target, prop) {
			if (prop === STATE_SYMBOL) return true;
			var s = sources.get(prop);
			var has = s !== void 0 && s.v !== UNINITIALIZED || Reflect.has(target, prop);
			if (s !== void 0 || active_effect !== null && (!has || get_descriptor(target, prop)?.writable)) {
				if (s === void 0) {
					s = with_parent(() => {
						var s$1 = /* @__PURE__ */ state(has ? proxy(target[prop]) : UNINITIALIZED, stack$1);
						if (true_default) tag(s$1, get_label(path, prop));
						return s$1;
					});
					sources.set(prop, s);
				}
				if (get(s) === UNINITIALIZED) return false;
			}
			return has;
		},
		set(target, prop, value$1, receiver) {
			var s = sources.get(prop);
			var has = prop in target;
			if (is_proxied_array && prop === "length") for (var i = value$1; i < s.v; i += 1) {
				var other_s = sources.get(i + "");
				if (other_s !== void 0) set(other_s, UNINITIALIZED);
				else if (i in target) {
					other_s = with_parent(() => /* @__PURE__ */ state(UNINITIALIZED, stack$1));
					sources.set(i + "", other_s);
					if (true_default) tag(other_s, get_label(path, i));
				}
			}
			if (s === void 0) {
				if (!has || get_descriptor(target, prop)?.writable) {
					s = with_parent(() => /* @__PURE__ */ state(void 0, stack$1));
					if (true_default) tag(s, get_label(path, prop));
					set(s, proxy(value$1));
					sources.set(prop, s);
				}
			} else {
				has = s.v !== UNINITIALIZED;
				var p = with_parent(() => proxy(value$1));
				set(s, p);
			}
			var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);
			if (descriptor?.set) descriptor.set.call(receiver, value$1);
			if (!has) {
				if (is_proxied_array && typeof prop === "string") {
					var ls = sources.get("length");
					var n = Number(prop);
					if (Number.isInteger(n) && n >= ls.v) set(ls, n + 1);
				}
				increment(version);
			}
			return true;
		},
		ownKeys(target) {
			get(version);
			var own_keys = Reflect.ownKeys(target).filter((key$1) => {
				var source$2 = sources.get(key$1);
				return source$2 === void 0 || source$2.v !== UNINITIALIZED;
			});
			for (var [key, source$1] of sources) if (source$1.v !== UNINITIALIZED && !(key in target)) own_keys.push(key);
			return own_keys;
		},
		setPrototypeOf() {
			state_prototype_fixed();
		}
	});
}
/**
* @param {string} path
* @param {string | symbol} prop
*/
function get_label(path, prop) {
	if (typeof prop === "symbol") return `${path}[Symbol(${prop.description ?? ""})]`;
	if (regex_is_valid_identifier.test(prop)) return `${path}.${prop}`;
	return /^\d+$/.test(prop) ? `${path}[${prop}]` : `${path}['${prop}']`;
}
/**
* @param {any} value
*/
function get_proxied_value(value) {
	try {
		if (value !== null && typeof value === "object" && STATE_SYMBOL in value) return value[STATE_SYMBOL];
	} catch {}
	return value;
}
/**
* @param {any} a
* @param {any} b
*/
function is(a, b) {
	return Object.is(get_proxied_value(a), get_proxied_value(b));
}
var ARRAY_MUTATING_METHODS = new Set([
	"copyWithin",
	"fill",
	"pop",
	"push",
	"reverse",
	"shift",
	"sort",
	"splice",
	"unshift"
]);
/**
* Wrap array mutating methods so $inspect is triggered only once and
* to prevent logging an array in intermediate state (e.g. with an empty slot)
* @param {any[]} array
*/
function inspectable_array(array) {
	return new Proxy(array, { get(target, prop, receiver) {
		var value = Reflect.get(target, prop, receiver);
		if (!ARRAY_MUTATING_METHODS.has(prop)) return value;
		/**
		* @this {any[]}
		* @param {any[]} args
		*/
		return function(...args) {
			set_eager_effects_deferred();
			var result = value.apply(this, args);
			flush_eager_effects();
			return result;
		};
	} });
}

//#endregion
//#region node_modules/svelte/src/internal/client/dev/equality.js
function init_array_prototype_warnings() {
	const array_prototype$1 = Array.prototype;
	const cleanup = Array.__svelte_cleanup;
	if (cleanup) cleanup();
	const { indexOf, lastIndexOf, includes } = array_prototype$1;
	array_prototype$1.indexOf = function(item, from_index) {
		const index = indexOf.call(this, item, from_index);
		if (index === -1) {
			for (let i = from_index ?? 0; i < this.length; i += 1) if (get_proxied_value(this[i]) === item) {
				state_proxy_equality_mismatch("array.indexOf(...)");
				break;
			}
		}
		return index;
	};
	array_prototype$1.lastIndexOf = function(item, from_index) {
		const index = lastIndexOf.call(this, item, from_index ?? this.length - 1);
		if (index === -1) {
			for (let i = 0; i <= (from_index ?? this.length - 1); i += 1) if (get_proxied_value(this[i]) === item) {
				state_proxy_equality_mismatch("array.lastIndexOf(...)");
				break;
			}
		}
		return index;
	};
	array_prototype$1.includes = function(item, from_index) {
		const has = includes.call(this, item, from_index);
		if (!has) {
			for (let i = 0; i < this.length; i += 1) if (get_proxied_value(this[i]) === item) {
				state_proxy_equality_mismatch("array.includes(...)");
				break;
			}
		}
		return has;
	};
	Array.__svelte_cleanup = () => {
		array_prototype$1.indexOf = indexOf;
		array_prototype$1.lastIndexOf = lastIndexOf;
		array_prototype$1.includes = includes;
	};
}
/**
* @param {any} a
* @param {any} b
* @param {boolean} equal
* @returns {boolean}
*/
function strict_equals(a, b, equal = true) {
	try {
		if (a === b !== (get_proxied_value(a) === get_proxied_value(b))) state_proxy_equality_mismatch(equal ? "===" : "!==");
	} catch {}
	return a === b === equal;
}
/**
* @param {any} a
* @param {any} b
* @param {boolean} equal
* @returns {boolean}
*/
function equals(a, b, equal = true) {
	if (a == b !== (get_proxied_value(a) == get_proxied_value(b))) state_proxy_equality_mismatch(equal ? "==" : "!=");
	return a == b === equal;
}

//#endregion
//#region node_modules/svelte/src/internal/client/dom/operations.js
/** @import { Effect, TemplateNode } from '#client' */
/** @type {Window} */
var $window;
/** @type {Document} */
var $document;
/** @type {boolean} */
var is_firefox;
/** @type {() => Node | null} */
var first_child_getter;
/** @type {() => Node | null} */
var next_sibling_getter;
/**
* Initialize these lazily to avoid issues when using the runtime in a server context
* where these globals are not available while avoiding a separate server entry point
*/
function init_operations() {
	if ($window !== void 0) return;
	$window = window;
	$document = document;
	is_firefox = /Firefox/.test(navigator.userAgent);
	var element_prototype = Element.prototype;
	var node_prototype = Node.prototype;
	var text_prototype = Text.prototype;
	first_child_getter = get_descriptor(node_prototype, "firstChild").get;
	next_sibling_getter = get_descriptor(node_prototype, "nextSibling").get;
	if (is_extensible(element_prototype)) {
		element_prototype.__click = void 0;
		element_prototype.__className = void 0;
		element_prototype.__attributes = null;
		element_prototype.__style = void 0;
		element_prototype.__e = void 0;
	}
	if (is_extensible(text_prototype)) text_prototype.__t = void 0;
	if (true_default) {
		element_prototype.__svelte_meta = null;
		init_array_prototype_warnings();
	}
}
/**
* @param {string} value
* @returns {Text}
*/
function create_text(value = "") {
	return document.createTextNode(value);
}
/**
* @template {Node} N
* @param {N} node
* @returns {Node | null}
*/
/* @__NO_SIDE_EFFECTS__ */
function get_first_child(node) {
	return first_child_getter.call(node);
}
/**
* @template {Node} N
* @param {N} node
* @returns {Node | null}
*/
/* @__NO_SIDE_EFFECTS__ */
function get_next_sibling(node) {
	return next_sibling_getter.call(node);
}
/**
* Don't mark this as side-effect-free, hydration needs to walk all nodes
* @template {Node} N
* @param {N} node
* @param {boolean} is_text
* @returns {Node | null}
*/
function child(node, is_text) {
	if (!hydrating) return /* @__PURE__ */ get_first_child(node);
	var child$1 = /* @__PURE__ */ get_first_child(hydrate_node);
	if (child$1 === null) child$1 = hydrate_node.appendChild(create_text());
	else if (is_text && child$1.nodeType !== TEXT_NODE) {
		var text = create_text();
		child$1?.before(text);
		set_hydrate_node(text);
		return text;
	}
	set_hydrate_node(child$1);
	return child$1;
}
/**
* Don't mark this as side-effect-free, hydration needs to walk all nodes
* @param {DocumentFragment | TemplateNode | TemplateNode[]} fragment
* @param {boolean} [is_text]
* @returns {Node | null}
*/
function first_child(fragment, is_text = false) {
	if (!hydrating) {
		var first = /* @__PURE__ */ get_first_child(fragment);
		if (first instanceof Comment && first.data === "") return /* @__PURE__ */ get_next_sibling(first);
		return first;
	}
	if (is_text && hydrate_node?.nodeType !== TEXT_NODE) {
		var text = create_text();
		hydrate_node?.before(text);
		set_hydrate_node(text);
		return text;
	}
	return hydrate_node;
}
/**
* Don't mark this as side-effect-free, hydration needs to walk all nodes
* @param {TemplateNode} node
* @param {number} count
* @param {boolean} is_text
* @returns {Node | null}
*/
function sibling(node, count = 1, is_text = false) {
	let next_sibling = hydrating ? hydrate_node : node;
	var last_sibling;
	while (count--) {
		last_sibling = next_sibling;
		next_sibling = /* @__PURE__ */ get_next_sibling(next_sibling);
	}
	if (!hydrating) return next_sibling;
	if (is_text && next_sibling?.nodeType !== TEXT_NODE) {
		var text = create_text();
		if (next_sibling === null) last_sibling?.after(text);
		else next_sibling.before(text);
		set_hydrate_node(text);
		return text;
	}
	set_hydrate_node(next_sibling);
	return next_sibling;
}
/**
* @template {Node} N
* @param {N} node
* @returns {void}
*/
function clear_text_content(node) {
	node.textContent = "";
}
/**
* Returns `true` if we're updating the current block, for example `condition` in
* an `{#if condition}` block just changed. In this case, the branch should be
* appended (or removed) at the same time as other updates within the
* current `<svelte:boundary>`
*/
function should_defer_append() {
	if (!async_mode_flag) return false;
	if (eager_block_effects !== null) return false;
	return (active_effect.f & EFFECT_RAN) !== 0;
}
/**
*
* @param {string} tag
* @param {string} [namespace]
* @param {string} [is]
* @returns
*/
function create_element(tag$1, namespace, is$1) {
	let options = is$1 ? { is: is$1 } : void 0;
	if (namespace) return document.createElementNS(namespace, tag$1, options);
	return document.createElement(tag$1, options);
}
function create_fragment() {
	return document.createDocumentFragment();
}
/**
* @param {string} data
* @returns
*/
function create_comment(data = "") {
	return document.createComment(data);
}
/**
* @param {Element} element
* @param {string} key
* @param {string} value
* @returns
*/
function set_attribute(element, key, value = "") {
	if (key.startsWith("xlink:")) {
		element.setAttributeNS("http://www.w3.org/1999/xlink", key, value);
		return;
	}
	return element.setAttribute(key, value);
}

//#endregion
//#region node_modules/svelte/src/internal/client/dom/elements/misc.js
/**
* @param {HTMLElement} dom
* @param {boolean} value
* @returns {void}
*/
function autofocus(dom, value) {
	if (value) {
		const body = document.body;
		dom.autofocus = true;
		queue_micro_task(() => {
			if (document.activeElement === body) dom.focus();
		});
	}
}
/**
* The child of a textarea actually corresponds to the defaultValue property, so we need
* to remove it upon hydration to avoid a bug when someone resets the form value.
* @param {HTMLTextAreaElement} dom
* @returns {void}
*/
function remove_textarea_child(dom) {
	if (hydrating && /* @__PURE__ */ get_first_child(dom) !== null) clear_text_content(dom);
}
var listening_to_form_reset = false;
function add_form_reset_listener() {
	if (!listening_to_form_reset) {
		listening_to_form_reset = true;
		document.addEventListener("reset", (evt) => {
			Promise.resolve().then(() => {
				if (!evt.defaultPrevented) for (const e of evt.target.elements) e.__on_r?.();
			});
		}, { capture: true });
	}
}

//#endregion
//#region node_modules/svelte/src/internal/client/dom/elements/bindings/shared.js
/**
* Fires the handler once immediately (unless corresponding arg is set to `false`),
* then listens to the given events until the render effect context is destroyed
* @param {EventTarget} target
* @param {Array<string>} events
* @param {(event?: Event) => void} handler
* @param {any} call_handler_immediately
*/
function listen(target, events, handler, call_handler_immediately = true) {
	if (call_handler_immediately) handler();
	for (var name of events) target.addEventListener(name, handler);
	teardown(() => {
		for (var name$1 of events) target.removeEventListener(name$1, handler);
	});
}
/**
* @template T
* @param {() => T} fn
*/
function without_reactive_context(fn) {
	var previous_reaction = active_reaction;
	var previous_effect = active_effect;
	set_active_reaction(null);
	set_active_effect(null);
	try {
		return fn();
	} finally {
		set_active_reaction(previous_reaction);
		set_active_effect(previous_effect);
	}
}
/**
* Listen to the given event, and then instantiate a global form reset listener if not already done,
* to notify all bindings when the form is reset
* @param {HTMLElement} element
* @param {string} event
* @param {(is_reset?: true) => void} handler
* @param {(is_reset?: true) => void} [on_reset]
*/
function listen_to_event_and_reset_event(element, event$1, handler, on_reset = handler) {
	element.addEventListener(event$1, () => without_reactive_context(handler));
	const prev = element.__on_r;
	if (prev) element.__on_r = () => {
		prev();
		on_reset(true);
	};
	else element.__on_r = () => on_reset(true);
	add_form_reset_listener();
}

//#endregion
//#region node_modules/svelte/src/internal/client/reactivity/effects.js
/** @import { ComponentContext, ComponentContextLegacy, Derived, Effect, TemplateNode, TransitionManager } from '#client' */
/**
* @param {'$effect' | '$effect.pre' | '$inspect'} rune
*/
function validate_effect(rune) {
	if (active_effect === null) {
		if (active_reaction === null) effect_orphan(rune);
		effect_in_unowned_derived();
	}
	if (is_destroying_effect) effect_in_teardown(rune);
}
/**
* @param {Effect} effect
* @param {Effect} parent_effect
*/
function push_effect(effect$1, parent_effect) {
	var parent_last = parent_effect.last;
	if (parent_last === null) parent_effect.last = parent_effect.first = effect$1;
	else {
		parent_last.next = effect$1;
		effect$1.prev = parent_last;
		parent_effect.last = effect$1;
	}
}
/**
* @param {number} type
* @param {null | (() => void | (() => void))} fn
* @param {boolean} sync
* @param {boolean} push
* @returns {Effect}
*/
function create_effect(type, fn, sync, push$1 = true) {
	var parent = active_effect;
	if (true_default) while (parent !== null && (parent.f & EAGER_EFFECT) !== 0) parent = parent.parent;
	if (parent !== null && (parent.f & INERT) !== 0) type |= INERT;
	/** @type {Effect} */
	var effect$1 = {
		ctx: component_context,
		deps: null,
		nodes_start: null,
		nodes_end: null,
		f: type | DIRTY | CONNECTED,
		first: null,
		fn,
		last: null,
		next: null,
		parent,
		b: parent && parent.b,
		prev: null,
		teardown: null,
		transitions: null,
		wv: 0,
		ac: null
	};
	if (true_default) effect$1.component_function = dev_current_component_function;
	if (sync) try {
		update_effect(effect$1);
		effect$1.f |= EFFECT_RAN;
	} catch (e$1) {
		destroy_effect(effect$1);
		throw e$1;
	}
	else if (fn !== null) schedule_effect(effect$1);
	if (push$1) {
		/** @type {Effect | null} */
		var e = effect$1;
		if (sync && e.deps === null && e.teardown === null && e.nodes_start === null && e.first === e.last && (e.f & EFFECT_PRESERVED) === 0) {
			e = e.first;
			if ((type & BLOCK_EFFECT) !== 0 && (type & EFFECT_TRANSPARENT) !== 0 && e !== null) e.f |= EFFECT_TRANSPARENT;
		}
		if (e !== null) {
			e.parent = parent;
			if (parent !== null) push_effect(e, parent);
			if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0 && (type & ROOT_EFFECT) === 0) {
				var derived$1 = active_reaction;
				(derived$1.effects ??= []).push(e);
			}
		}
	}
	return effect$1;
}
/**
* Internal representation of `$effect.tracking()`
* @returns {boolean}
*/
function effect_tracking() {
	return active_reaction !== null && !untracking;
}
/**
* @param {() => void} fn
*/
function teardown(fn) {
	const effect$1 = create_effect(RENDER_EFFECT, null, false);
	set_signal_status(effect$1, CLEAN);
	effect$1.teardown = fn;
	return effect$1;
}
/**
* Internal representation of `$effect(...)`
* @param {() => void | (() => void)} fn
*/
function user_effect(fn) {
	validate_effect("$effect");
	if (true_default) define_property(fn, "name", { value: "$effect" });
	var flags$1 = active_effect.f;
	if (!active_reaction && (flags$1 & BRANCH_EFFECT) !== 0 && (flags$1 & EFFECT_RAN) === 0) {
		var context = component_context;
		(context.e ??= []).push(fn);
	} else return create_user_effect(fn);
}
/**
* @param {() => void | (() => void)} fn
*/
function create_user_effect(fn) {
	return create_effect(EFFECT | USER_EFFECT, fn, false);
}
/**
* Internal representation of `$effect.pre(...)`
* @param {() => void | (() => void)} fn
* @returns {Effect}
*/
function user_pre_effect(fn) {
	validate_effect("$effect.pre");
	if (true_default) define_property(fn, "name", { value: "$effect.pre" });
	return create_effect(RENDER_EFFECT | USER_EFFECT, fn, true);
}
/** @param {() => void | (() => void)} fn */
function eager_effect(fn) {
	return create_effect(EAGER_EFFECT, fn, true);
}
/**
* Internal representation of `$effect.root(...)`
* @param {() => void | (() => void)} fn
* @returns {() => void}
*/
function effect_root(fn) {
	Batch.ensure();
	const effect$1 = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
	return () => {
		destroy_effect(effect$1);
	};
}
/**
* An effect root whose children can transition out
* @param {() => void} fn
* @returns {(options?: { outro?: boolean }) => Promise<void>}
*/
function component_root(fn) {
	Batch.ensure();
	const effect$1 = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
	return (options = {}) => {
		return new Promise((fulfil) => {
			if (options.outro) pause_effect(effect$1, () => {
				destroy_effect(effect$1);
				fulfil(void 0);
			});
			else {
				destroy_effect(effect$1);
				fulfil(void 0);
			}
		});
	};
}
/**
* @param {() => void | (() => void)} fn
* @returns {Effect}
*/
function effect(fn) {
	return create_effect(EFFECT, fn, false);
}
/**
* Internal representation of `$: ..`
* @param {() => any} deps
* @param {() => void | (() => void)} fn
*/
function legacy_pre_effect(deps, fn) {
	var context = component_context;
	/** @type {{ effect: null | Effect, ran: boolean, deps: () => any }} */
	var token = {
		effect: null,
		ran: false,
		deps
	};
	context.l.$.push(token);
	token.effect = render_effect(() => {
		deps();
		if (token.ran) return;
		token.ran = true;
		untrack(fn);
	});
}
function legacy_pre_effect_reset() {
	var context = component_context;
	render_effect(() => {
		for (var token of context.l.$) {
			token.deps();
			var effect$1 = token.effect;
			if ((effect$1.f & CLEAN) !== 0) set_signal_status(effect$1, MAYBE_DIRTY);
			if (is_dirty(effect$1)) update_effect(effect$1);
			token.ran = false;
		}
	});
}
/**
* @param {() => void | (() => void)} fn
* @returns {Effect}
*/
function async_effect(fn) {
	return create_effect(ASYNC | EFFECT_PRESERVED, fn, true);
}
/**
* @param {() => void | (() => void)} fn
* @returns {Effect}
*/
function render_effect(fn, flags$1 = 0) {
	return create_effect(RENDER_EFFECT | flags$1, fn, true);
}
/**
* @param {(...expressions: any) => void | (() => void)} fn
* @param {Array<() => any>} sync
* @param {Array<() => Promise<any>>} async
* @param {Array<Promise<void>>} blockers
* @param {boolean} defer
*/
function template_effect(fn, sync = [], async = [], blockers = [], defer = false) {
	flatten(blockers, sync, async, (values) => {
		create_effect(defer ? EFFECT : RENDER_EFFECT, () => fn(...values.map(get)), true);
	});
}
/**
* @param {(() => void)} fn
* @param {number} flags
*/
function block(fn, flags$1 = 0) {
	var effect$1 = create_effect(BLOCK_EFFECT | flags$1, fn, true);
	if (true_default) effect$1.dev_stack = dev_stack;
	return effect$1;
}
/**
* @param {(() => void)} fn
* @param {boolean} [push]
*/
function branch(fn, push$1 = true) {
	return create_effect(BRANCH_EFFECT | EFFECT_PRESERVED, fn, true, push$1);
}
/**
* @param {Effect} effect
*/
function execute_effect_teardown(effect$1) {
	var teardown$1 = effect$1.teardown;
	if (teardown$1 !== null) {
		const previously_destroying_effect = is_destroying_effect;
		const previous_reaction = active_reaction;
		set_is_destroying_effect(true);
		set_active_reaction(null);
		try {
			teardown$1.call(null);
		} finally {
			set_is_destroying_effect(previously_destroying_effect);
			set_active_reaction(previous_reaction);
		}
	}
}
/**
* @param {Effect} signal
* @param {boolean} remove_dom
* @returns {void}
*/
function destroy_effect_children(signal, remove_dom = false) {
	var effect$1 = signal.first;
	signal.first = signal.last = null;
	while (effect$1 !== null) {
		const controller = effect$1.ac;
		if (controller !== null) without_reactive_context(() => {
			controller.abort(STALE_REACTION);
		});
		var next$1 = effect$1.next;
		if ((effect$1.f & ROOT_EFFECT) !== 0) effect$1.parent = null;
		else destroy_effect(effect$1, remove_dom);
		effect$1 = next$1;
	}
}
/**
* @param {Effect} signal
* @returns {void}
*/
function destroy_block_effect_children(signal) {
	var effect$1 = signal.first;
	while (effect$1 !== null) {
		var next$1 = effect$1.next;
		if ((effect$1.f & BRANCH_EFFECT) === 0) destroy_effect(effect$1);
		effect$1 = next$1;
	}
}
/**
* @param {Effect} effect
* @param {boolean} [remove_dom]
* @returns {void}
*/
function destroy_effect(effect$1, remove_dom = true) {
	var removed = false;
	if ((remove_dom || (effect$1.f & HEAD_EFFECT) !== 0) && effect$1.nodes_start !== null && effect$1.nodes_end !== null) {
		remove_effect_dom(effect$1.nodes_start, effect$1.nodes_end);
		removed = true;
	}
	destroy_effect_children(effect$1, remove_dom && !removed);
	remove_reactions(effect$1, 0);
	set_signal_status(effect$1, DESTROYED);
	var transitions = effect$1.transitions;
	if (transitions !== null) for (const transition of transitions) transition.stop();
	execute_effect_teardown(effect$1);
	var parent = effect$1.parent;
	if (parent !== null && parent.first !== null) unlink_effect(effect$1);
	if (true_default) effect$1.component_function = null;
	effect$1.next = effect$1.prev = effect$1.teardown = effect$1.ctx = effect$1.deps = effect$1.fn = effect$1.nodes_start = effect$1.nodes_end = effect$1.ac = null;
}
/**
*
* @param {TemplateNode | null} node
* @param {TemplateNode} end
*/
function remove_effect_dom(node, end) {
	while (node !== null) {
		/** @type {TemplateNode | null} */
		var next$1 = node === end ? null : /* @__PURE__ */ get_next_sibling(node);
		node.remove();
		node = next$1;
	}
}
/**
* Detach an effect from the effect tree, freeing up memory and
* reducing the amount of work that happens on subsequent traversals
* @param {Effect} effect
*/
function unlink_effect(effect$1) {
	var parent = effect$1.parent;
	var prev = effect$1.prev;
	var next$1 = effect$1.next;
	if (prev !== null) prev.next = next$1;
	if (next$1 !== null) next$1.prev = prev;
	if (parent !== null) {
		if (parent.first === effect$1) parent.first = next$1;
		if (parent.last === effect$1) parent.last = prev;
	}
}
/**
* When a block effect is removed, we don't immediately destroy it or yank it
* out of the DOM, because it might have transitions. Instead, we 'pause' it.
* It stays around (in memory, and in the DOM) until outro transitions have
* completed, and if the state change is reversed then we _resume_ it.
* A paused effect does not update, and the DOM subtree becomes inert.
* @param {Effect} effect
* @param {() => void} [callback]
* @param {boolean} [destroy]
*/
function pause_effect(effect$1, callback, destroy = true) {
	/** @type {TransitionManager[]} */
	var transitions = [];
	pause_children(effect$1, transitions, true);
	run_out_transitions(transitions, () => {
		if (destroy) destroy_effect(effect$1);
		if (callback) callback();
	});
}
/**
* @param {TransitionManager[]} transitions
* @param {() => void} fn
*/
function run_out_transitions(transitions, fn) {
	var remaining = transitions.length;
	if (remaining > 0) {
		var check = () => --remaining || fn();
		for (var transition of transitions) transition.out(check);
	} else fn();
}
/**
* @param {Effect} effect
* @param {TransitionManager[]} transitions
* @param {boolean} local
*/
function pause_children(effect$1, transitions, local) {
	if ((effect$1.f & INERT) !== 0) return;
	effect$1.f ^= INERT;
	if (effect$1.transitions !== null) {
		for (const transition of effect$1.transitions) if (transition.is_global || local) transitions.push(transition);
	}
	var child$1 = effect$1.first;
	while (child$1 !== null) {
		var sibling$1 = child$1.next;
		var transparent = (child$1.f & EFFECT_TRANSPARENT) !== 0 || (child$1.f & BRANCH_EFFECT) !== 0 && (effect$1.f & BLOCK_EFFECT) !== 0;
		pause_children(child$1, transitions, transparent ? local : false);
		child$1 = sibling$1;
	}
}
/**
* The opposite of `pause_effect`. We call this if (for example)
* `x` becomes falsy then truthy: `{#if x}...{/if}`
* @param {Effect} effect
*/
function resume_effect(effect$1) {
	resume_children(effect$1, true);
}
/**
* @param {Effect} effect
* @param {boolean} local
*/
function resume_children(effect$1, local) {
	if ((effect$1.f & INERT) === 0) return;
	effect$1.f ^= INERT;
	if ((effect$1.f & CLEAN) === 0) {
		set_signal_status(effect$1, DIRTY);
		schedule_effect(effect$1);
	}
	var child$1 = effect$1.first;
	while (child$1 !== null) {
		var sibling$1 = child$1.next;
		var transparent = (child$1.f & EFFECT_TRANSPARENT) !== 0 || (child$1.f & BRANCH_EFFECT) !== 0;
		resume_children(child$1, transparent ? local : false);
		child$1 = sibling$1;
	}
	if (effect$1.transitions !== null) {
		for (const transition of effect$1.transitions) if (transition.is_global || local) transition.in();
	}
}
function aborted(effect$1 = active_effect) {
	return (effect$1.f & DESTROYED) !== 0;
}
/**
* @param {Effect} effect
* @param {DocumentFragment} fragment
*/
function move_effect(effect$1, fragment) {
	var node = effect$1.nodes_start;
	var end = effect$1.nodes_end;
	while (node !== null) {
		/** @type {TemplateNode | null} */
		var next$1 = node === end ? null : /* @__PURE__ */ get_next_sibling(node);
		fragment.append(node);
		node = next$1;
	}
}

//#endregion
//#region node_modules/svelte/src/internal/client/legacy.js
/** @import { Value } from '#client' */
/**
* @type {Set<Value> | null}
* @deprecated
*/
let captured_signals = null;
/**
* Capture an array of all the signals that are read when `fn` is called
* @template T
* @param {() => T} fn
*/
function capture_signals(fn) {
	var previous_captured_signals = captured_signals;
	try {
		captured_signals = /* @__PURE__ */ new Set();
		untrack(fn);
		if (previous_captured_signals !== null) for (var signal of captured_signals) previous_captured_signals.add(signal);
		return captured_signals;
	} finally {
		captured_signals = previous_captured_signals;
	}
}
/**
* Invokes a function and captures all signals that are read during the invocation,
* then invalidates them.
* @param {() => any} fn
* @deprecated
*/
function invalidate_inner_signals(fn) {
	for (var signal of capture_signals(fn)) internal_set(signal, signal.v);
}

//#endregion
//#region node_modules/svelte/src/internal/client/runtime.js
/** @import { Derived, Effect, Reaction, Signal, Source, Value } from '#client' */
let is_updating_effect = false;
/** @param {boolean} value */
function set_is_updating_effect(value) {
	is_updating_effect = value;
}
let is_destroying_effect = false;
/** @param {boolean} value */
function set_is_destroying_effect(value) {
	is_destroying_effect = value;
}
/** @type {null | Reaction} */
let active_reaction = null;
let untracking = false;
/** @param {null | Reaction} reaction */
function set_active_reaction(reaction) {
	active_reaction = reaction;
}
/** @type {null | Effect} */
let active_effect = null;
/** @param {null | Effect} effect */
function set_active_effect(effect$1) {
	active_effect = effect$1;
}
/**
* When sources are created within a reaction, reading and writing
* them within that reaction should not cause a re-run
* @type {null | Source[]}
*/
let current_sources = null;
/** @param {Value} value */
function push_reaction_value(value) {
	if (active_reaction !== null && (!async_mode_flag || (active_reaction.f & DERIVED) !== 0)) if (current_sources === null) current_sources = [value];
	else current_sources.push(value);
}
/**
* The dependencies of the reaction that is currently being executed. In many cases,
* the dependencies are unchanged between runs, and so this will be `null` unless
* and until a new dependency is accessed — we track this via `skipped_deps`
* @type {null | Value[]}
*/
var new_deps = null;
var skipped_deps = 0;
/**
* Tracks writes that the effect it's executed in doesn't listen to yet,
* so that the dependency can be added to the effect later on if it then reads it
* @type {null | Source[]}
*/
let untracked_writes = null;
/** @param {null | Source[]} value */
function set_untracked_writes(value) {
	untracked_writes = value;
}
/**
* @type {number} Used by sources and deriveds for handling updates.
* Version starts from 1 so that unowned deriveds differentiate between a created effect and a run one for tracing
**/
let write_version = 1;
/** @type {number} Used to version each read of a source of derived to avoid duplicating depedencies inside a reaction */
var read_version = 0;
let update_version = read_version;
/** @param {number} value */
function set_update_version(value) {
	update_version = value;
}
function increment_write_version() {
	return ++write_version;
}
/**
* Determines whether a derived or effect is dirty.
* If it is MAYBE_DIRTY, will set the status to CLEAN
* @param {Reaction} reaction
* @returns {boolean}
*/
function is_dirty(reaction) {
	var flags$1 = reaction.f;
	if ((flags$1 & DIRTY) !== 0) return true;
	if (flags$1 & DERIVED) reaction.f &= ~WAS_MARKED;
	if ((flags$1 & MAYBE_DIRTY) !== 0) {
		var dependencies = reaction.deps;
		if (dependencies !== null) {
			var length = dependencies.length;
			for (var i = 0; i < length; i++) {
				var dependency = dependencies[i];
				if (is_dirty(dependency)) update_derived(dependency);
				if (dependency.wv > reaction.wv) return true;
			}
		}
		if ((flags$1 & CONNECTED) !== 0 && batch_values === null) set_signal_status(reaction, CLEAN);
	}
	return false;
}
/**
* @param {Value} signal
* @param {Effect} effect
* @param {boolean} [root]
*/
function schedule_possible_effect_self_invalidation(signal, effect$1, root = true) {
	var reactions = signal.reactions;
	if (reactions === null) return;
	if (!async_mode_flag && current_sources?.includes(signal)) return;
	for (var i = 0; i < reactions.length; i++) {
		var reaction = reactions[i];
		if ((reaction.f & DERIVED) !== 0) schedule_possible_effect_self_invalidation(reaction, effect$1, false);
		else if (effect$1 === reaction) {
			if (root) set_signal_status(reaction, DIRTY);
			else if ((reaction.f & CLEAN) !== 0) set_signal_status(reaction, MAYBE_DIRTY);
			schedule_effect(reaction);
		}
	}
}
/** @param {Reaction} reaction */
function update_reaction(reaction) {
	var previous_deps = new_deps;
	var previous_skipped_deps = skipped_deps;
	var previous_untracked_writes = untracked_writes;
	var previous_reaction = active_reaction;
	var previous_sources = current_sources;
	var previous_component_context = component_context;
	var previous_untracking = untracking;
	var previous_update_version = update_version;
	var flags$1 = reaction.f;
	new_deps = null;
	skipped_deps = 0;
	untracked_writes = null;
	active_reaction = (flags$1 & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
	current_sources = null;
	set_component_context(reaction.ctx);
	untracking = false;
	update_version = ++read_version;
	if (reaction.ac !== null) {
		without_reactive_context(() => {
			/** @type {AbortController} */ reaction.ac.abort(STALE_REACTION);
		});
		reaction.ac = null;
	}
	try {
		reaction.f |= REACTION_IS_UPDATING;
		var fn = reaction.fn;
		var result = fn();
		var deps = reaction.deps;
		if (new_deps !== null) {
			var i;
			remove_reactions(reaction, skipped_deps);
			if (deps !== null && skipped_deps > 0) {
				deps.length = skipped_deps + new_deps.length;
				for (i = 0; i < new_deps.length; i++) deps[skipped_deps + i] = new_deps[i];
			} else reaction.deps = deps = new_deps;
			if (is_updating_effect && effect_tracking() && (reaction.f & CONNECTED) !== 0) for (i = skipped_deps; i < deps.length; i++) (deps[i].reactions ??= []).push(reaction);
		} else if (deps !== null && skipped_deps < deps.length) {
			remove_reactions(reaction, skipped_deps);
			deps.length = skipped_deps;
		}
		if (is_runes() && untracked_writes !== null && !untracking && deps !== null && (reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0) for (i = 0; i < untracked_writes.length; i++) schedule_possible_effect_self_invalidation(untracked_writes[i], reaction);
		if (previous_reaction !== null && previous_reaction !== reaction) {
			read_version++;
			if (untracked_writes !== null) if (previous_untracked_writes === null) previous_untracked_writes = untracked_writes;
			else previous_untracked_writes.push(...untracked_writes);
		}
		if ((reaction.f & ERROR_VALUE) !== 0) reaction.f ^= ERROR_VALUE;
		return result;
	} catch (error) {
		return handle_error(error);
	} finally {
		reaction.f ^= REACTION_IS_UPDATING;
		new_deps = previous_deps;
		skipped_deps = previous_skipped_deps;
		untracked_writes = previous_untracked_writes;
		active_reaction = previous_reaction;
		current_sources = previous_sources;
		set_component_context(previous_component_context);
		untracking = previous_untracking;
		update_version = previous_update_version;
	}
}
/**
* @template V
* @param {Reaction} signal
* @param {Value<V>} dependency
* @returns {void}
*/
function remove_reaction(signal, dependency) {
	let reactions = dependency.reactions;
	if (reactions !== null) {
		var index = index_of.call(reactions, signal);
		if (index !== -1) {
			var new_length = reactions.length - 1;
			if (new_length === 0) reactions = dependency.reactions = null;
			else {
				reactions[index] = reactions[new_length];
				reactions.pop();
			}
		}
	}
	if (reactions === null && (dependency.f & DERIVED) !== 0 && (new_deps === null || !new_deps.includes(dependency))) {
		set_signal_status(dependency, MAYBE_DIRTY);
		if ((dependency.f & CONNECTED) !== 0) {
			dependency.f ^= CONNECTED;
			dependency.f &= ~WAS_MARKED;
		}
		destroy_derived_effects(dependency);
		remove_reactions(dependency, 0);
	}
}
/**
* @param {Reaction} signal
* @param {number} start_index
* @returns {void}
*/
function remove_reactions(signal, start_index) {
	var dependencies = signal.deps;
	if (dependencies === null) return;
	for (var i = start_index; i < dependencies.length; i++) remove_reaction(signal, dependencies[i]);
}
/**
* @param {Effect} effect
* @returns {void}
*/
function update_effect(effect$1) {
	var flags$1 = effect$1.f;
	if ((flags$1 & DESTROYED) !== 0) return;
	set_signal_status(effect$1, CLEAN);
	var previous_effect = active_effect;
	var was_updating_effect = is_updating_effect;
	active_effect = effect$1;
	is_updating_effect = true;
	if (true_default) {
		var previous_component_fn = dev_current_component_function;
		set_dev_current_component_function(effect$1.component_function);
		var previous_stack = dev_stack;
		set_dev_stack(effect$1.dev_stack ?? dev_stack);
	}
	try {
		if ((flags$1 & BLOCK_EFFECT) !== 0) destroy_block_effect_children(effect$1);
		else destroy_effect_children(effect$1);
		execute_effect_teardown(effect$1);
		var teardown$1 = update_reaction(effect$1);
		effect$1.teardown = typeof teardown$1 === "function" ? teardown$1 : null;
		effect$1.wv = write_version;
		if (true_default && tracing_mode_flag && (effect$1.f & DIRTY) !== 0 && effect$1.deps !== null) {
			for (var dep of effect$1.deps) if (dep.set_during_effect) {
				dep.wv = increment_write_version();
				dep.set_during_effect = false;
			}
		}
	} finally {
		is_updating_effect = was_updating_effect;
		active_effect = previous_effect;
		if (true_default) {
			set_dev_current_component_function(previous_component_fn);
			set_dev_stack(previous_stack);
		}
	}
}
/**
* Returns a promise that resolves once any pending state changes have been applied.
* @returns {Promise<void>}
*/
async function tick() {
	if (async_mode_flag) return new Promise((f) => {
		requestAnimationFrame(() => f());
		setTimeout(() => f());
	});
	await Promise.resolve();
	flushSync();
}
/**
* Returns a promise that resolves once any state changes, and asynchronous work resulting from them,
* have resolved and the DOM has been updated
* @returns {Promise<void>}
* @since 5.36
*/
function settled() {
	return Batch.ensure().settled();
}
/**
* @template V
* @param {Value<V>} signal
* @returns {V}
*/
function get(signal) {
	var is_derived = (signal.f & DERIVED) !== 0;
	captured_signals?.add(signal);
	if (active_reaction !== null && !untracking) {
		if (!(active_effect !== null && (active_effect.f & DESTROYED) !== 0) && !current_sources?.includes(signal)) {
			var deps = active_reaction.deps;
			if ((active_reaction.f & REACTION_IS_UPDATING) !== 0) {
				if (signal.rv < read_version) {
					signal.rv = read_version;
					if (new_deps === null && deps !== null && deps[skipped_deps] === signal) skipped_deps++;
					else if (new_deps === null) new_deps = [signal];
					else if (!new_deps.includes(signal)) new_deps.push(signal);
				}
			} else {
				(active_reaction.deps ??= []).push(signal);
				var reactions = signal.reactions;
				if (reactions === null) signal.reactions = [active_reaction];
				else if (!reactions.includes(active_reaction)) reactions.push(active_reaction);
			}
		}
	}
	if (true_default) {
		recent_async_deriveds.delete(signal);
		if (tracing_mode_flag && !untracking && tracing_expressions !== null && active_reaction !== null && tracing_expressions.reaction === active_reaction) if (signal.trace) signal.trace();
		else {
			var trace$1 = get_stack("traced at");
			if (trace$1) {
				var entry = tracing_expressions.entries.get(signal);
				if (entry === void 0) {
					entry = { traces: [] };
					tracing_expressions.entries.set(signal, entry);
				}
				var last = entry.traces[entry.traces.length - 1];
				if (trace$1.stack !== last?.stack) entry.traces.push(trace$1);
			}
		}
	}
	if (is_destroying_effect) {
		if (old_values.has(signal)) return old_values.get(signal);
		if (is_derived) {
			var derived$1 = signal;
			var value = derived$1.v;
			if ((derived$1.f & CLEAN) === 0 && derived$1.reactions !== null || depends_on_old_values(derived$1)) value = execute_derived(derived$1);
			old_values.set(derived$1, value);
			return value;
		}
	} else if (is_derived) {
		derived$1 = signal;
		if (batch_values?.has(derived$1)) return batch_values.get(derived$1);
		if (is_dirty(derived$1)) update_derived(derived$1);
		if (is_updating_effect && effect_tracking() && (derived$1.f & CONNECTED) === 0) reconnect(derived$1);
	} else if (batch_values?.has(signal)) return batch_values.get(signal);
	if ((signal.f & ERROR_VALUE) !== 0) throw signal.v;
	return signal.v;
}
/**
* (Re)connect a disconnected derived, so that it is notified
* of changes in `mark_reactions`
* @param {Derived} derived
*/
function reconnect(derived$1) {
	if (derived$1.deps === null) return;
	derived$1.f ^= CONNECTED;
	for (const dep of derived$1.deps) {
		(dep.reactions ??= []).push(derived$1);
		if ((dep.f & DERIVED) !== 0 && (dep.f & CONNECTED) === 0) reconnect(dep);
	}
}
/** @param {Derived} derived */
function depends_on_old_values(derived$1) {
	if (derived$1.v === UNINITIALIZED) return true;
	if (derived$1.deps === null) return false;
	for (const dep of derived$1.deps) {
		if (old_values.has(dep)) return true;
		if ((dep.f & DERIVED) !== 0 && depends_on_old_values(dep)) return true;
	}
	return false;
}
/**
* Like `get`, but checks for `undefined`. Used for `var` declarations because they can be accessed before being declared
* @template V
* @param {Value<V> | undefined} signal
* @returns {V | undefined}
*/
function safe_get(signal) {
	return signal && get(signal);
}
/**
* When used inside a [`$derived`](https://svelte.dev/docs/svelte/$derived) or [`$effect`](https://svelte.dev/docs/svelte/$effect),
* any state read inside `fn` will not be treated as a dependency.
*
* ```ts
* $effect(() => {
*   // this will run when `data` changes, but not when `time` changes
*   save(data, {
*     timestamp: untrack(() => time)
*   });
* });
* ```
* @template T
* @param {() => T} fn
* @returns {T}
*/
function untrack(fn) {
	var previous_untracking = untracking;
	try {
		untracking = true;
		return fn();
	} finally {
		untracking = previous_untracking;
	}
}
var STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);
/**
* @param {Signal} signal
* @param {number} status
* @returns {void}
*/
function set_signal_status(signal, status) {
	signal.f = signal.f & STATUS_MASK | status;
}
/**
* @param {Record<string | symbol, unknown>} obj
* @param {Array<string | symbol>} keys
* @returns {Record<string | symbol, unknown>}
*/
function exclude_from_object(obj, keys) {
	/** @type {Record<string | symbol, unknown>} */
	var result = {};
	for (var key in obj) if (!keys.includes(key)) result[key] = obj[key];
	for (var symbol of Object.getOwnPropertySymbols(obj)) if (Object.propertyIsEnumerable.call(obj, symbol) && !keys.includes(symbol)) result[symbol] = obj[symbol];
	return result;
}
/**
* Possibly traverse an object and read all its properties so that they're all reactive in case this is `$state`.
* Does only check first level of an object for performance reasons (heuristic should be good for 99% of all cases).
* @param {any} value
* @returns {void}
*/
function deep_read_state(value) {
	if (typeof value !== "object" || !value || value instanceof EventTarget) return;
	if (STATE_SYMBOL in value) deep_read(value);
	else if (!Array.isArray(value)) for (let key in value) {
		const prop = value[key];
		if (typeof prop === "object" && prop && STATE_SYMBOL in prop) deep_read(prop);
	}
}
/**
* Deeply traverse an object and read all its properties
* so that they're all reactive in case this is `$state`
* @param {any} value
* @param {Set<any>} visited
* @returns {void}
*/
function deep_read(value, visited = /* @__PURE__ */ new Set()) {
	if (typeof value === "object" && value !== null && !(value instanceof EventTarget) && !visited.has(value)) {
		visited.add(value);
		if (value instanceof Date) value.getTime();
		for (let key in value) try {
			deep_read(value[key], visited);
		} catch (e) {}
		const proto = get_prototype_of(value);
		if (proto !== Object.prototype && proto !== Array.prototype && proto !== Map.prototype && proto !== Set.prototype && proto !== Date.prototype) {
			const descriptors = get_descriptors(proto);
			for (let key in descriptors) {
				const get$1 = descriptors[key].get;
				if (get$1) try {
					get$1.call(value);
				} catch (e) {}
			}
		}
	}
}

//#endregion
//#region node_modules/svelte/src/internal/client/dom/elements/events.js
/** @type {Set<string>} */
const all_registered_events = /* @__PURE__ */ new Set();
/** @type {Set<(events: Array<string>) => void>} */
const root_event_handles = /* @__PURE__ */ new Set();
/**
* SSR adds onload and onerror attributes to catch those events before the hydration.
* This function detects those cases, removes the attributes and replays the events.
* @param {HTMLElement} dom
*/
function replay_events(dom) {
	if (!hydrating) return;
	dom.removeAttribute("onload");
	dom.removeAttribute("onerror");
	const event$1 = dom.__e;
	if (event$1 !== void 0) {
		dom.__e = void 0;
		queueMicrotask(() => {
			if (dom.isConnected) dom.dispatchEvent(event$1);
		});
	}
}
/**
* @param {string} event_name
* @param {EventTarget} dom
* @param {EventListener} [handler]
* @param {AddEventListenerOptions} [options]
*/
function create_event(event_name, dom, handler, options = {}) {
	/**
	* @this {EventTarget}
	*/
	function target_handler(event$1) {
		if (!options.capture) handle_event_propagation.call(dom, event$1);
		if (!event$1.cancelBubble) return without_reactive_context(() => {
			return handler?.call(this, event$1);
		});
	}
	if (event_name.startsWith("pointer") || event_name.startsWith("touch") || event_name === "wheel") queue_micro_task(() => {
		dom.addEventListener(event_name, target_handler, options);
	});
	else dom.addEventListener(event_name, target_handler, options);
	return target_handler;
}
/**
* Attaches an event handler to an element and returns a function that removes the handler. Using this
* rather than `addEventListener` will preserve the correct order relative to handlers added declaratively
* (with attributes like `onclick`), which use event delegation for performance reasons
*
* @param {EventTarget} element
* @param {string} type
* @param {EventListener} handler
* @param {AddEventListenerOptions} [options]
*/
function on(element, type, handler, options = {}) {
	var target_handler = create_event(type, element, handler, options);
	return () => {
		element.removeEventListener(type, target_handler, options);
	};
}
/**
* @param {string} event_name
* @param {Element} dom
* @param {EventListener} [handler]
* @param {boolean} [capture]
* @param {boolean} [passive]
* @returns {void}
*/
function event(event_name, dom, handler, capture$1, passive) {
	var options = {
		capture: capture$1,
		passive
	};
	var target_handler = create_event(event_name, dom, handler, options);
	if (dom === document.body || dom === window || dom === document || dom instanceof HTMLMediaElement) teardown(() => {
		dom.removeEventListener(event_name, target_handler, options);
	});
}
/**
* @param {Array<string>} events
* @returns {void}
*/
function delegate(events) {
	for (var i = 0; i < events.length; i++) all_registered_events.add(events[i]);
	for (var fn of root_event_handles) fn(events);
}
var last_propagated_event = null;
/**
* @this {EventTarget}
* @param {Event} event
* @returns {void}
*/
function handle_event_propagation(event$1) {
	var handler_element = this;
	var owner_document = handler_element.ownerDocument;
	var event_name = event$1.type;
	var path = event$1.composedPath?.() || [];
	var current_target = path[0] || event$1.target;
	last_propagated_event = event$1;
	var path_idx = 0;
	var handled_at = last_propagated_event === event$1 && event$1.__root;
	if (handled_at) {
		var at_idx = path.indexOf(handled_at);
		if (at_idx !== -1 && (handler_element === document || handler_element === window)) {
			event$1.__root = handler_element;
			return;
		}
		var handler_idx = path.indexOf(handler_element);
		if (handler_idx === -1) return;
		if (at_idx <= handler_idx) path_idx = at_idx;
	}
	current_target = path[path_idx] || event$1.target;
	if (current_target === handler_element) return;
	define_property(event$1, "currentTarget", {
		configurable: true,
		get() {
			return current_target || owner_document;
		}
	});
	var previous_reaction = active_reaction;
	var previous_effect = active_effect;
	set_active_reaction(null);
	set_active_effect(null);
	try {
		/**
		* @type {unknown}
		*/
		var throw_error;
		/**
		* @type {unknown[]}
		*/
		var other_errors = [];
		while (current_target !== null) {
			/** @type {null | Element} */
			var parent_element = current_target.assignedSlot || current_target.parentNode || current_target.host || null;
			try {
				var delegated = current_target["__" + event_name];
				if (delegated != null && (!current_target.disabled || event$1.target === current_target)) delegated.call(current_target, event$1);
			} catch (error) {
				if (throw_error) other_errors.push(error);
				else throw_error = error;
			}
			if (event$1.cancelBubble || parent_element === handler_element || parent_element === null) break;
			current_target = parent_element;
		}
		if (throw_error) {
			for (let error of other_errors) queueMicrotask(() => {
				throw error;
			});
			throw throw_error;
		}
	} finally {
		event$1.__root = handler_element;
		delete event$1.currentTarget;
		set_active_reaction(previous_reaction);
		set_active_effect(previous_effect);
	}
}
/**
* In dev, warn if an event handler is not a function, as it means the
* user probably called the handler or forgot to add a `() =>`
* @param {() => (event: Event, ...args: any) => void} thunk
* @param {EventTarget} element
* @param {[Event, ...any]} args
* @param {any} component
* @param {[number, number]} [loc]
* @param {boolean} [remove_parens]
*/
function apply(thunk, element, args, component, loc, has_side_effects = false, remove_parens = false) {
	let handler;
	let error;
	try {
		handler = thunk();
	} catch (e) {
		error = e;
	}
	if (typeof handler !== "function" && (has_side_effects || handler != null || error)) {
		const filename = component?.[FILENAME];
		const location = loc ? ` at ${filename}:${loc[0]}:${loc[1]}` : ` in ${filename}`;
		const phase = args[0]?.eventPhase < Event.BUBBLING_PHASE ? "capture" : "";
		const description = `\`${args[0]?.type + phase}\` handler${location}`;
		const suggestion = remove_parens ? "remove the trailing `()`" : "add a leading `() =>`";
		event_handler_invalid(description, suggestion);
		if (error) throw error;
	}
	handler?.apply(element, args);
}

//#endregion
export { autofocus as $, TEMPLATE_FRAGMENT as $n, to_array as $r, previous_batch as $t, destroy_effect as A, set_hydrate_node as An, EFFECT_TRANSPARENT as Ar, async_derived as At, remove_effect_dom as B, HMR as Bn, deferred as Br, save as Bt, untrack as C, hydrate_next as Cn, svelte_element_invalid_this_value as Cr, mutable_source as Ct, block as D, next as Dn, DIRTY as Dr, state as Dt, aborted as E, hydrating as En, DESTROYED as Er, source as Et, legacy_pre_effect as F, EACH_IS_ANIMATED as Fn, LOADING_ATTR_SYMBOL as Fr, capture as Ft, template_effect as G, NAMESPACE_HTML as Gn, get_prototype_of as Gr, pending as Gt, resume_effect as H, HYDRATION_ERROR as Hn, fallback as Hr, unset_context as Ht, legacy_pre_effect_reset as I, EACH_IS_CONTROLLED as In, MAYBE_DIRTY as Ir, flatten as It, validate_effect as J, PROPS_IS_BINDABLE as Jn, is_promise as Jr, current_batch as Jt, user_effect as K, NAMESPACE_MATHML as Kn, is_array as Kr, createSubscriber as Kt, move_effect as L, EACH_ITEM_IMMUTABLE as Ln, STATE_SYMBOL as Lr, for_await_track_reactivity_loss as Lt, effect as M, skip_nodes as Mn, HEAD_EFFECT as Mr, derived_safe_equal as Mt, effect_root as N, ATTACHMENT_KEY as Nn, INERT as Nr, user_derived as Nt, branch as O, read_hydration_instruction as On, DOCUMENT_FRAGMENT_NODE as Or, update as Ot, effect_tracking as P, EACH_INDEX_REACTIVE as Pn, LEGACY_PROPS as Pr, async_body as Pt, add_form_reset_listener as Q, PROPS_IS_UPDATED as Qn, run_all as Qr, is_flushing_sync as Qt, pause_children as R, EACH_ITEM_REACTIVE as Rn, TEXT_NODE as Rr, run as Rt, tick as S, safe_not_equal as Sn, store_invalid_shape as Sr, internal_set as St, invalidate_inner_signals as T, hydrate_template as Tn, COMMENT_NODE as Tr, set as Tt, run_out_transitions as U, HYDRATION_START as Un, get_descriptor as Ur, boundary as Ut, render_effect as V, HYDRATION_END as Vn, define_property as Vr, track_reactivity_loss as Vt, teardown as W, HYDRATION_START_ELSE as Wn, get_descriptors as Wr, get_boundary as Wt, listen_to_event_and_reset_event as X, PROPS_IS_LAZY_INITIAL as Xn, object_keys as Xr, flushSync as Xt, listen as Y, PROPS_IS_IMMUTABLE as Yn, noop as Yr, eager as Yt, without_reactive_context as Z, PROPS_IS_RUNES as Zn, run$1 as Zr, fork as Zt, safe_get as _, tag as _n, rune_outside_svelte as _r, equals as _t, event as a, dev_current_component_function as an, TRANSITION_OUT as ar, create_comment as at, set_signal_status as b, snapshot as bn, lifecycle_outside_component as br, proxy as bt, replay_events as c, getContext as cn, component_api_changed as cr, create_text as ct, active_reaction as d, pop as dn, get_abort_signal_outside_reaction as dr, get_next_sibling as dt, invoke_error_boundary as en, TEMPLATE_USE_IMPORT_NODE as er, remove_textarea_child as et, deep_read as f, push as fn, hydration_failed as fr, init_operations as ft, is_destroying_effect as g, label as gn, props_rest_readonly as gr, sibling as gt, get as h, get_stack as hn, props_invalid_value as hr, should_defer_append as ht, delegate as i, createContext as in, TRANSITION_IN as ir, clear_text_content as it, eager_effect as j, set_hydrating as jn, ELEMENT_NODE as jr, derived as jt, component_root as k, reset as kn, EFFECT_RAN as kr, update_pre as kt, root_event_handles as l, hasContext as ln, component_api_invalid_new as lr, first_child as lt, exclude_from_object as m, set_dev_current_component_function as mn, lifecycle_legacy_only as mr, set_attribute as mt, apply as n, add_svelte_meta as nn, TEMPLATE_USE_SVG as nr, $window as nt, handle_event_propagation as o, dev_stack as on, UNINITIALIZED as or, create_element as ot, deep_read_state as p, setContext as pn, invalid_snippet as pr, is_firefox as pt, user_pre_effect as q, NAMESPACE_SVG as qn, is_function as qr, Batch as qt, create_event as r, component_context as rn, TRANSITION_GLOBAL as rr, child as rt, on as s, getAllContexts as sn, bind_invalid_checkbox_value as sr, create_fragment as st, all_registered_events as t, queue_micro_task as tn, TEMPLATE_USE_MATHML as tr, $document as tt, active_effect as u, is_runes as un, each_key_duplicate as ur, get_first_child as ut, set_active_effect as v, tag_proxy as vn, invalid_default_snippet as vr, strict_equals as vt, update_version as w, hydrate_node as wn, BLOCK_EFFECT as wr, mutate as wt, settled as x, dynamic_void_element_content as xn, snippet_without_render_tag as xr, increment as xt, set_active_reaction as y, trace as yn, invalid_snippet_arguments as yr, is as yt, pause_effect as z, FILENAME as zn, array_from as zr, run_after_blockers as zt };
//# sourceMappingURL=events-CwpACFa3.js.map