{"version":3,"file":"legacy-client-CIDjJgkg.js","names":["hash","text","events","passive","unmount","anchor_node","DEV","#instance","#events","DEV","handlers"],"sources":["../../svelte/src/utils.js","../../svelte/src/internal/client/dom/reconciler.js","../../svelte/src/internal/client/dom/template.js","../../svelte/src/internal/client/render.js","../../svelte/src/internal/client/dom/legacy/event-modifiers.js","../../svelte/src/legacy/legacy-client.js"],"sourcesContent":["const regex_return_characters = /\\r/g;\n\n/**\n * @param {string} str\n * @returns {string}\n */\nexport function hash(str) {\n\tstr = str.replace(regex_return_characters, '');\n\tlet hash = 5381;\n\tlet i = str.length;\n\n\twhile (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n\treturn (hash >>> 0).toString(36);\n}\n\nconst VOID_ELEMENT_NAMES = [\n\t'area',\n\t'base',\n\t'br',\n\t'col',\n\t'command',\n\t'embed',\n\t'hr',\n\t'img',\n\t'input',\n\t'keygen',\n\t'link',\n\t'meta',\n\t'param',\n\t'source',\n\t'track',\n\t'wbr'\n];\n\n/**\n * Returns `true` if `name` is of a void element\n * @param {string} name\n */\nexport function is_void(name) {\n\treturn VOID_ELEMENT_NAMES.includes(name) || name.toLowerCase() === '!doctype';\n}\n\nconst RESERVED_WORDS = [\n\t'arguments',\n\t'await',\n\t'break',\n\t'case',\n\t'catch',\n\t'class',\n\t'const',\n\t'continue',\n\t'debugger',\n\t'default',\n\t'delete',\n\t'do',\n\t'else',\n\t'enum',\n\t'eval',\n\t'export',\n\t'extends',\n\t'false',\n\t'finally',\n\t'for',\n\t'function',\n\t'if',\n\t'implements',\n\t'import',\n\t'in',\n\t'instanceof',\n\t'interface',\n\t'let',\n\t'new',\n\t'null',\n\t'package',\n\t'private',\n\t'protected',\n\t'public',\n\t'return',\n\t'static',\n\t'super',\n\t'switch',\n\t'this',\n\t'throw',\n\t'true',\n\t'try',\n\t'typeof',\n\t'var',\n\t'void',\n\t'while',\n\t'with',\n\t'yield'\n];\n\n/**\n * Returns `true` if `word` is a reserved JavaScript keyword\n * @param {string} word\n */\nexport function is_reserved(word) {\n\treturn RESERVED_WORDS.includes(word);\n}\n\n/**\n * @param {string} name\n */\nexport function is_capture_event(name) {\n\treturn name.endsWith('capture') && name !== 'gotpointercapture' && name !== 'lostpointercapture';\n}\n\n/** List of Element events that will be delegated */\nconst DELEGATED_EVENTS = [\n\t'beforeinput',\n\t'click',\n\t'change',\n\t'dblclick',\n\t'contextmenu',\n\t'focusin',\n\t'focusout',\n\t'input',\n\t'keydown',\n\t'keyup',\n\t'mousedown',\n\t'mousemove',\n\t'mouseout',\n\t'mouseover',\n\t'mouseup',\n\t'pointerdown',\n\t'pointermove',\n\t'pointerout',\n\t'pointerover',\n\t'pointerup',\n\t'touchend',\n\t'touchmove',\n\t'touchstart'\n];\n\n/**\n * Returns `true` if `event_name` is a delegated event\n * @param {string} event_name\n */\nexport function can_delegate_event(event_name) {\n\treturn DELEGATED_EVENTS.includes(event_name);\n}\n\n/**\n * Attributes that are boolean, i.e. they are present or not present.\n */\nconst DOM_BOOLEAN_ATTRIBUTES = [\n\t'allowfullscreen',\n\t'async',\n\t'autofocus',\n\t'autoplay',\n\t'checked',\n\t'controls',\n\t'default',\n\t'disabled',\n\t'formnovalidate',\n\t'indeterminate',\n\t'inert',\n\t'ismap',\n\t'loop',\n\t'multiple',\n\t'muted',\n\t'nomodule',\n\t'novalidate',\n\t'open',\n\t'playsinline',\n\t'readonly',\n\t'required',\n\t'reversed',\n\t'seamless',\n\t'selected',\n\t'webkitdirectory',\n\t'defer',\n\t'disablepictureinpicture',\n\t'disableremoteplayback'\n];\n\n/**\n * Returns `true` if `name` is a boolean attribute\n * @param {string} name\n */\nexport function is_boolean_attribute(name) {\n\treturn DOM_BOOLEAN_ATTRIBUTES.includes(name);\n}\n\n/**\n * @type {Record<string, string>}\n * List of attribute names that should be aliased to their property names\n * because they behave differently between setting them as an attribute and\n * setting them as a property.\n */\nconst ATTRIBUTE_ALIASES = {\n\t// no `class: 'className'` because we handle that separately\n\tformnovalidate: 'formNoValidate',\n\tismap: 'isMap',\n\tnomodule: 'noModule',\n\tplaysinline: 'playsInline',\n\treadonly: 'readOnly',\n\tdefaultvalue: 'defaultValue',\n\tdefaultchecked: 'defaultChecked',\n\tsrcobject: 'srcObject',\n\tnovalidate: 'noValidate',\n\tallowfullscreen: 'allowFullscreen',\n\tdisablepictureinpicture: 'disablePictureInPicture',\n\tdisableremoteplayback: 'disableRemotePlayback'\n};\n\n/**\n * @param {string} name\n */\nexport function normalize_attribute(name) {\n\tname = name.toLowerCase();\n\treturn ATTRIBUTE_ALIASES[name] ?? name;\n}\n\nconst DOM_PROPERTIES = [\n\t...DOM_BOOLEAN_ATTRIBUTES,\n\t'formNoValidate',\n\t'isMap',\n\t'noModule',\n\t'playsInline',\n\t'readOnly',\n\t'value',\n\t'volume',\n\t'defaultValue',\n\t'defaultChecked',\n\t'srcObject',\n\t'noValidate',\n\t'allowFullscreen',\n\t'disablePictureInPicture',\n\t'disableRemotePlayback'\n];\n\n/**\n * @param {string} name\n */\nexport function is_dom_property(name) {\n\treturn DOM_PROPERTIES.includes(name);\n}\n\nconst NON_STATIC_PROPERTIES = ['autofocus', 'muted', 'defaultValue', 'defaultChecked'];\n\n/**\n * Returns `true` if the given attribute cannot be set through the template\n * string, i.e. needs some kind of JavaScript handling to work.\n * @param {string} name\n */\nexport function cannot_be_set_statically(name) {\n\treturn NON_STATIC_PROPERTIES.includes(name);\n}\n\n/**\n * Subset of delegated events which should be passive by default.\n * These two are already passive via browser defaults on window, document and body.\n * But since\n * - we're delegating them\n * - they happen often\n * - they apply to mobile which is generally less performant\n * we're marking them as passive by default for other elements, too.\n */\nconst PASSIVE_EVENTS = ['touchstart', 'touchmove'];\n\n/**\n * Returns `true` if `name` is a passive event\n * @param {string} name\n */\nexport function is_passive_event(name) {\n\treturn PASSIVE_EVENTS.includes(name);\n}\n\nconst CONTENT_EDITABLE_BINDINGS = ['textContent', 'innerHTML', 'innerText'];\n\n/** @param {string} name */\nexport function is_content_editable_binding(name) {\n\treturn CONTENT_EDITABLE_BINDINGS.includes(name);\n}\n\nconst LOAD_ERROR_ELEMENTS = [\n\t'body',\n\t'embed',\n\t'iframe',\n\t'img',\n\t'link',\n\t'object',\n\t'script',\n\t'style',\n\t'track'\n];\n\n/**\n * Returns `true` if the element emits `load` and `error` events\n * @param {string} name\n */\nexport function is_load_error_element(name) {\n\treturn LOAD_ERROR_ELEMENTS.includes(name);\n}\n\nconst SVG_ELEMENTS = [\n\t'altGlyph',\n\t'altGlyphDef',\n\t'altGlyphItem',\n\t'animate',\n\t'animateColor',\n\t'animateMotion',\n\t'animateTransform',\n\t'circle',\n\t'clipPath',\n\t'color-profile',\n\t'cursor',\n\t'defs',\n\t'desc',\n\t'discard',\n\t'ellipse',\n\t'feBlend',\n\t'feColorMatrix',\n\t'feComponentTransfer',\n\t'feComposite',\n\t'feConvolveMatrix',\n\t'feDiffuseLighting',\n\t'feDisplacementMap',\n\t'feDistantLight',\n\t'feDropShadow',\n\t'feFlood',\n\t'feFuncA',\n\t'feFuncB',\n\t'feFuncG',\n\t'feFuncR',\n\t'feGaussianBlur',\n\t'feImage',\n\t'feMerge',\n\t'feMergeNode',\n\t'feMorphology',\n\t'feOffset',\n\t'fePointLight',\n\t'feSpecularLighting',\n\t'feSpotLight',\n\t'feTile',\n\t'feTurbulence',\n\t'filter',\n\t'font',\n\t'font-face',\n\t'font-face-format',\n\t'font-face-name',\n\t'font-face-src',\n\t'font-face-uri',\n\t'foreignObject',\n\t'g',\n\t'glyph',\n\t'glyphRef',\n\t'hatch',\n\t'hatchpath',\n\t'hkern',\n\t'image',\n\t'line',\n\t'linearGradient',\n\t'marker',\n\t'mask',\n\t'mesh',\n\t'meshgradient',\n\t'meshpatch',\n\t'meshrow',\n\t'metadata',\n\t'missing-glyph',\n\t'mpath',\n\t'path',\n\t'pattern',\n\t'polygon',\n\t'polyline',\n\t'radialGradient',\n\t'rect',\n\t'set',\n\t'solidcolor',\n\t'stop',\n\t'svg',\n\t'switch',\n\t'symbol',\n\t'text',\n\t'textPath',\n\t'tref',\n\t'tspan',\n\t'unknown',\n\t'use',\n\t'view',\n\t'vkern'\n];\n\n/** @param {string} name */\nexport function is_svg(name) {\n\treturn SVG_ELEMENTS.includes(name);\n}\n\nconst MATHML_ELEMENTS = [\n\t'annotation',\n\t'annotation-xml',\n\t'maction',\n\t'math',\n\t'merror',\n\t'mfrac',\n\t'mi',\n\t'mmultiscripts',\n\t'mn',\n\t'mo',\n\t'mover',\n\t'mpadded',\n\t'mphantom',\n\t'mprescripts',\n\t'mroot',\n\t'mrow',\n\t'ms',\n\t'mspace',\n\t'msqrt',\n\t'mstyle',\n\t'msub',\n\t'msubsup',\n\t'msup',\n\t'mtable',\n\t'mtd',\n\t'mtext',\n\t'mtr',\n\t'munder',\n\t'munderover',\n\t'semantics'\n];\n\n/** @param {string} name */\nexport function is_mathml(name) {\n\treturn MATHML_ELEMENTS.includes(name);\n}\n\nconst STATE_CREATION_RUNES = /** @type {const} */ ([\n\t'$state',\n\t'$state.raw',\n\t'$derived',\n\t'$derived.by'\n]);\n\nconst RUNES = /** @type {const} */ ([\n\t...STATE_CREATION_RUNES,\n\t'$state.eager',\n\t'$state.snapshot',\n\t'$props',\n\t'$props.id',\n\t'$bindable',\n\t'$effect',\n\t'$effect.pre',\n\t'$effect.tracking',\n\t'$effect.root',\n\t'$effect.pending',\n\t'$inspect',\n\t'$inspect().with',\n\t'$inspect.trace',\n\t'$host'\n]);\n\n/** @typedef {typeof RUNES[number]} RuneName */\n\n/**\n * @param {string} name\n * @returns {name is RuneName}\n */\nexport function is_rune(name) {\n\treturn RUNES.includes(/** @type {RuneName} */ (name));\n}\n\n/** @typedef {typeof STATE_CREATION_RUNES[number]} StateCreationRuneName */\n\n/**\n * @param {string} name\n * @returns {name is StateCreationRuneName}\n */\nexport function is_state_creation_rune(name) {\n\treturn STATE_CREATION_RUNES.includes(/** @type {StateCreationRuneName} */ (name));\n}\n\n/** List of elements that require raw contents and should not have SSR comments put in them */\nconst RAW_TEXT_ELEMENTS = /** @type {const} */ (['textarea', 'script', 'style', 'title']);\n\n/** @param {string} name */\nexport function is_raw_text_element(name) {\n\treturn RAW_TEXT_ELEMENTS.includes(/** @type {typeof RAW_TEXT_ELEMENTS[number]} */ (name));\n}\n\n/**\n * Prevent devtools trying to make `location` a clickable link by inserting a zero-width space\n * @template {string | undefined} T\n * @param {T} location\n * @returns {T};\n */\nexport function sanitize_location(location) {\n\treturn /** @type {T} */ (location?.replace(/\\//g, '/\\u200b'));\n}\n","/** @param {string} html */\nexport function create_fragment_from_html(html) {\n\tvar elem = document.createElement('template');\n\telem.innerHTML = html.replaceAll('<!>', '<!---->'); // XHTML compliance\n\treturn elem.content;\n}\n","/** @import { Effect, TemplateNode } from '#client' */\n/** @import { TemplateStructure } from './types' */\nimport { hydrate_next, hydrate_node, hydrating, set_hydrate_node } from './hydration.js';\nimport {\n\tcreate_text,\n\tget_first_child,\n\tis_firefox,\n\tcreate_element,\n\tcreate_fragment,\n\tcreate_comment,\n\tset_attribute\n} from './operations.js';\nimport { create_fragment_from_html } from './reconciler.js';\nimport { active_effect } from '../runtime.js';\nimport {\n\tNAMESPACE_MATHML,\n\tNAMESPACE_SVG,\n\tTEMPLATE_FRAGMENT,\n\tTEMPLATE_USE_IMPORT_NODE,\n\tTEMPLATE_USE_MATHML,\n\tTEMPLATE_USE_SVG\n} from '../../../constants.js';\nimport { COMMENT_NODE, DOCUMENT_FRAGMENT_NODE, EFFECT_RAN, TEXT_NODE } from '#client/constants';\n\n/**\n * @param {TemplateNode} start\n * @param {TemplateNode | null} end\n */\nexport function assign_nodes(start, end) {\n\tvar effect = /** @type {Effect} */ (active_effect);\n\tif (effect.nodes_start === null) {\n\t\teffect.nodes_start = start;\n\t\teffect.nodes_end = end;\n\t}\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function from_html(content, flags) {\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;\n\n\t/** @type {Node} */\n\tvar node;\n\n\t/**\n\t * Whether or not the first item is a text/element node. If not, we need to\n\t * create an additional comment node to act as `effect.nodes.start`\n\t */\n\tvar has_start = !content.startsWith('<!>');\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tassign_nodes(hydrate_node, null);\n\t\t\treturn hydrate_node;\n\t\t}\n\n\t\tif (node === undefined) {\n\t\t\tnode = create_fragment_from_html(has_start ? content : '<!>' + content);\n\t\t\tif (!is_fragment) node = /** @type {Node} */ (get_first_child(node));\n\t\t}\n\n\t\tvar clone = /** @type {TemplateNode} */ (\n\t\t\tuse_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)\n\t\t);\n\n\t\tif (is_fragment) {\n\t\t\tvar start = /** @type {TemplateNode} */ (get_first_child(clone));\n\t\t\tvar end = /** @type {TemplateNode} */ (clone.lastChild);\n\n\t\t\tassign_nodes(start, end);\n\t\t} else {\n\t\t\tassign_nodes(clone, clone);\n\t\t}\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @param {'svg' | 'math'} ns\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nfunction from_namespace(content, flags, ns = 'svg') {\n\t/**\n\t * Whether or not the first item is a text/element node. If not, we need to\n\t * create an additional comment node to act as `effect.nodes.start`\n\t */\n\tvar has_start = !content.startsWith('<!>');\n\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar wrapped = `<${ns}>${has_start ? content : '<!>' + content}</${ns}>`;\n\n\t/** @type {Element | DocumentFragment} */\n\tvar node;\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tassign_nodes(hydrate_node, null);\n\t\t\treturn hydrate_node;\n\t\t}\n\n\t\tif (!node) {\n\t\t\tvar fragment = /** @type {DocumentFragment} */ (create_fragment_from_html(wrapped));\n\t\t\tvar root = /** @type {Element} */ (get_first_child(fragment));\n\n\t\t\tif (is_fragment) {\n\t\t\t\tnode = document.createDocumentFragment();\n\t\t\t\twhile (get_first_child(root)) {\n\t\t\t\t\tnode.appendChild(/** @type {Node} */ (get_first_child(root)));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode = /** @type {Element} */ (get_first_child(root));\n\t\t\t}\n\t\t}\n\n\t\tvar clone = /** @type {TemplateNode} */ (node.cloneNode(true));\n\n\t\tif (is_fragment) {\n\t\t\tvar start = /** @type {TemplateNode} */ (get_first_child(clone));\n\t\t\tvar end = /** @type {TemplateNode} */ (clone.lastChild);\n\n\t\t\tassign_nodes(start, end);\n\t\t} else {\n\t\t\tassign_nodes(clone, clone);\n\t\t}\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function from_svg(content, flags) {\n\treturn from_namespace(content, flags, 'svg');\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function from_mathml(content, flags) {\n\treturn from_namespace(content, flags, 'math');\n}\n\n/**\n * @param {TemplateStructure[]} structure\n * @param {typeof NAMESPACE_SVG | typeof NAMESPACE_MATHML | undefined} [ns]\n */\nfunction fragment_from_tree(structure, ns) {\n\tvar fragment = create_fragment();\n\n\tfor (var item of structure) {\n\t\tif (typeof item === 'string') {\n\t\t\tfragment.append(create_text(item));\n\t\t\tcontinue;\n\t\t}\n\n\t\t// if `preserveComments === true`, comments are represented as `['// <data>']`\n\t\tif (item === undefined || item[0][0] === '/') {\n\t\t\tfragment.append(create_comment(item ? item[0].slice(3) : ''));\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst [name, attributes, ...children] = item;\n\n\t\tconst namespace = name === 'svg' ? NAMESPACE_SVG : name === 'math' ? NAMESPACE_MATHML : ns;\n\n\t\tvar element = create_element(name, namespace, attributes?.is);\n\n\t\tfor (var key in attributes) {\n\t\t\tset_attribute(element, key, attributes[key]);\n\t\t}\n\n\t\tif (children.length > 0) {\n\t\t\tvar target =\n\t\t\t\telement.tagName === 'TEMPLATE'\n\t\t\t\t\t? /** @type {HTMLTemplateElement} */ (element).content\n\t\t\t\t\t: element;\n\n\t\t\ttarget.append(\n\t\t\t\tfragment_from_tree(children, element.tagName === 'foreignObject' ? undefined : namespace)\n\t\t\t);\n\t\t}\n\n\t\tfragment.append(element);\n\t}\n\n\treturn fragment;\n}\n\n/**\n * @param {TemplateStructure[]} structure\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function from_tree(structure, flags) {\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;\n\n\t/** @type {Node} */\n\tvar node;\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tassign_nodes(hydrate_node, null);\n\t\t\treturn hydrate_node;\n\t\t}\n\n\t\tif (node === undefined) {\n\t\t\tconst ns =\n\t\t\t\t(flags & TEMPLATE_USE_SVG) !== 0\n\t\t\t\t\t? NAMESPACE_SVG\n\t\t\t\t\t: (flags & TEMPLATE_USE_MATHML) !== 0\n\t\t\t\t\t\t? NAMESPACE_MATHML\n\t\t\t\t\t\t: undefined;\n\n\t\t\tnode = fragment_from_tree(structure, ns);\n\t\t\tif (!is_fragment) node = /** @type {Node} */ (get_first_child(node));\n\t\t}\n\n\t\tvar clone = /** @type {TemplateNode} */ (\n\t\t\tuse_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)\n\t\t);\n\n\t\tif (is_fragment) {\n\t\t\tvar start = /** @type {TemplateNode} */ (get_first_child(clone));\n\t\t\tvar end = /** @type {TemplateNode} */ (clone.lastChild);\n\n\t\t\tassign_nodes(start, end);\n\t\t} else {\n\t\t\tassign_nodes(clone, clone);\n\t\t}\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {() => Element | DocumentFragment} fn\n */\nexport function with_script(fn) {\n\treturn () => run_scripts(fn());\n}\n\n/**\n * Creating a document fragment from HTML that contains script tags will not execute\n * the scripts. We need to replace the script tags with new ones so that they are executed.\n * @param {Element | DocumentFragment} node\n * @returns {Node | Node[]}\n */\nfunction run_scripts(node) {\n\t// scripts were SSR'd, in which case they will run\n\tif (hydrating) return node;\n\n\tconst is_fragment = node.nodeType === DOCUMENT_FRAGMENT_NODE;\n\tconst scripts =\n\t\t/** @type {HTMLElement} */ (node).tagName === 'SCRIPT'\n\t\t\t? [/** @type {HTMLScriptElement} */ (node)]\n\t\t\t: node.querySelectorAll('script');\n\tconst effect = /** @type {Effect} */ (active_effect);\n\n\tfor (const script of scripts) {\n\t\tconst clone = document.createElement('script');\n\t\tfor (var attribute of script.attributes) {\n\t\t\tclone.setAttribute(attribute.name, attribute.value);\n\t\t}\n\n\t\tclone.textContent = script.textContent;\n\n\t\t// The script has changed - if it's at the edges, the effect now points at dead nodes\n\t\tif (is_fragment ? node.firstChild === script : node === script) {\n\t\t\teffect.nodes_start = clone;\n\t\t}\n\t\tif (is_fragment ? node.lastChild === script : node === script) {\n\t\t\teffect.nodes_end = clone;\n\t\t}\n\n\t\tscript.replaceWith(clone);\n\t}\n\treturn node;\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @param {any} value\n */\nexport function text(value = '') {\n\tif (!hydrating) {\n\t\tvar t = create_text(value + '');\n\t\tassign_nodes(t, t);\n\t\treturn t;\n\t}\n\n\tvar node = hydrate_node;\n\n\tif (node.nodeType !== TEXT_NODE) {\n\t\t// if an {expression} is empty during SSR, we need to insert an empty text node\n\t\tnode.before((node = create_text()));\n\t\tset_hydrate_node(node);\n\t}\n\n\tassign_nodes(node, node);\n\treturn node;\n}\n\n/**\n * @returns {TemplateNode | DocumentFragment}\n */\nexport function comment() {\n\t// we're not delegating to `template` here for performance reasons\n\tif (hydrating) {\n\t\tassign_nodes(hydrate_node, null);\n\t\treturn hydrate_node;\n\t}\n\n\tvar frag = document.createDocumentFragment();\n\tvar start = document.createComment('');\n\tvar anchor = create_text();\n\tfrag.append(start, anchor);\n\n\tassign_nodes(start, anchor);\n\n\treturn frag;\n}\n\n/**\n * Assign the created (or in hydration mode, traversed) dom elements to the current block\n * and insert the elements into the dom (in client mode).\n * @param {Text | Comment | Element} anchor\n * @param {DocumentFragment | Element} dom\n */\nexport function append(anchor, dom) {\n\tif (hydrating) {\n\t\tvar effect = /** @type {Effect} */ (active_effect);\n\t\t// When hydrating and outer component and an inner component is async, i.e. blocked on a promise,\n\t\t// then by the time the inner resolves we have already advanced to the end of the hydrated nodes\n\t\t// of the parent component. Check for defined for that reason to avoid rewinding the parent's end marker.\n\t\tif ((effect.f & EFFECT_RAN) === 0 || effect.nodes_end === null) {\n\t\t\teffect.nodes_end = hydrate_node;\n\t\t}\n\t\thydrate_next();\n\t\treturn;\n\t}\n\n\tif (anchor === null) {\n\t\t// edge case — void `<svelte:element>` with content\n\t\treturn;\n\t}\n\n\tanchor.before(/** @type {Node} */ (dom));\n}\n\n/**\n * Create (or hydrate) an unique UID for the component instance.\n */\nexport function props_id() {\n\tif (\n\t\thydrating &&\n\t\thydrate_node &&\n\t\thydrate_node.nodeType === COMMENT_NODE &&\n\t\thydrate_node.textContent?.startsWith(`$`)\n\t) {\n\t\tconst id = hydrate_node.textContent.substring(1);\n\t\thydrate_next();\n\t\treturn id;\n\t}\n\n\t// @ts-expect-error This way we ensure the id is unique even across Svelte runtimes\n\t(window.__svelte ??= {}).uid ??= 1;\n\n\t// @ts-expect-error\n\treturn `c${window.__svelte.uid++}`;\n}\n","/** @import { ComponentContext, Effect, TemplateNode } from '#client' */\n/** @import { Component, ComponentType, SvelteComponent, MountOptions } from '../../index.js' */\nimport { DEV } from 'esm-env';\nimport {\n\tclear_text_content,\n\tcreate_text,\n\tget_first_child,\n\tget_next_sibling,\n\tinit_operations\n} from './dom/operations.js';\nimport { HYDRATION_END, HYDRATION_ERROR, HYDRATION_START } from '../../constants.js';\nimport { active_effect } from './runtime.js';\nimport { push, pop, component_context } from './context.js';\nimport { component_root } from './reactivity/effects.js';\nimport { hydrate_node, hydrating, set_hydrate_node, set_hydrating } from './dom/hydration.js';\nimport { array_from } from '../shared/utils.js';\nimport {\n\tall_registered_events,\n\thandle_event_propagation,\n\troot_event_handles\n} from './dom/elements/events.js';\nimport * as w from './warnings.js';\nimport * as e from './errors.js';\nimport { assign_nodes } from './dom/template.js';\nimport { is_passive_event } from '../../utils.js';\nimport { COMMENT_NODE, STATE_SYMBOL } from './constants.js';\nimport { boundary } from './dom/blocks/boundary.js';\n\n/**\n * This is normally true — block effects should run their intro transitions —\n * but is false during hydration (unless `options.intro` is `true`) and\n * when creating the children of a `<svelte:element>` that just changed tag\n */\nexport let should_intro = true;\n\n/** @param {boolean} value */\nexport function set_should_intro(value) {\n\tshould_intro = value;\n}\n\n/**\n * @param {Element} text\n * @param {string} value\n * @returns {void}\n */\nexport function set_text(text, value) {\n\t// For objects, we apply string coercion (which might make things like $state array references in the template reactive) before diffing\n\tvar str = value == null ? '' : typeof value === 'object' ? value + '' : value;\n\t// @ts-expect-error\n\tif (str !== (text.__t ??= text.nodeValue)) {\n\t\t// @ts-expect-error\n\t\ttext.__t = str;\n\t\ttext.nodeValue = str + '';\n\t}\n}\n\n/**\n * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component.\n * Transitions will play during the initial render unless the `intro` option is set to `false`.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component\n * @param {MountOptions<Props>} options\n * @returns {Exports}\n */\nexport function mount(component, options) {\n\treturn _mount(component, options);\n}\n\n/**\n * Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component\n * @param {{} extends Props ? {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tprops?: Props;\n * \t\tevents?: Record<string, (e: any) => any>;\n *  \tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t\trecover?: boolean;\n * \t} : {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tprops: Props;\n * \t\tevents?: Record<string, (e: any) => any>;\n *  \tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t\trecover?: boolean;\n * \t}} options\n * @returns {Exports}\n */\nexport function hydrate(component, options) {\n\tinit_operations();\n\toptions.intro = options.intro ?? false;\n\tconst target = options.target;\n\tconst was_hydrating = hydrating;\n\tconst previous_hydrate_node = hydrate_node;\n\n\ttry {\n\t\tvar anchor = /** @type {TemplateNode} */ (get_first_child(target));\n\t\twhile (\n\t\t\tanchor &&\n\t\t\t(anchor.nodeType !== COMMENT_NODE || /** @type {Comment} */ (anchor).data !== HYDRATION_START)\n\t\t) {\n\t\t\tanchor = /** @type {TemplateNode} */ (get_next_sibling(anchor));\n\t\t}\n\n\t\tif (!anchor) {\n\t\t\tthrow HYDRATION_ERROR;\n\t\t}\n\n\t\tset_hydrating(true);\n\t\tset_hydrate_node(/** @type {Comment} */ (anchor));\n\n\t\tconst instance = _mount(component, { ...options, anchor });\n\n\t\tset_hydrating(false);\n\n\t\treturn /**  @type {Exports} */ (instance);\n\t} catch (error) {\n\t\t// re-throw Svelte errors - they are certainly not related to hydration\n\t\tif (\n\t\t\terror instanceof Error &&\n\t\t\terror.message.split('\\n').some((line) => line.startsWith('https://svelte.dev/e/'))\n\t\t) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error !== HYDRATION_ERROR) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.warn('Failed to hydrate: ', error);\n\t\t}\n\n\t\tif (options.recover === false) {\n\t\t\te.hydration_failed();\n\t\t}\n\n\t\t// If an error occurred above, the operations might not yet have been initialised.\n\t\tinit_operations();\n\t\tclear_text_content(target);\n\n\t\tset_hydrating(false);\n\t\treturn mount(component, options);\n\t} finally {\n\t\tset_hydrating(was_hydrating);\n\t\tset_hydrate_node(previous_hydrate_node);\n\t}\n}\n\n/** @type {Map<string, number>} */\nconst document_listeners = new Map();\n\n/**\n * @template {Record<string, any>} Exports\n * @param {ComponentType<SvelteComponent<any>> | Component<any>} Component\n * @param {MountOptions} options\n * @returns {Exports}\n */\nfunction _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {\n\tinit_operations();\n\n\t/** @type {Set<string>} */\n\tvar registered_events = new Set();\n\n\t/** @param {Array<string>} events */\n\tvar event_handle = (events) => {\n\t\tfor (var i = 0; i < events.length; i++) {\n\t\t\tvar event_name = events[i];\n\n\t\t\tif (registered_events.has(event_name)) continue;\n\t\t\tregistered_events.add(event_name);\n\n\t\t\tvar passive = is_passive_event(event_name);\n\n\t\t\t// Add the event listener to both the container and the document.\n\t\t\t// The container listener ensures we catch events from within in case\n\t\t\t// the outer content stops propagation of the event.\n\t\t\ttarget.addEventListener(event_name, handle_event_propagation, { passive });\n\n\t\t\tvar n = document_listeners.get(event_name);\n\n\t\t\tif (n === undefined) {\n\t\t\t\t// The document listener ensures we catch events that originate from elements that were\n\t\t\t\t// manually moved outside of the container (e.g. via manual portals).\n\t\t\t\tdocument.addEventListener(event_name, handle_event_propagation, { passive });\n\t\t\t\tdocument_listeners.set(event_name, 1);\n\t\t\t} else {\n\t\t\t\tdocument_listeners.set(event_name, n + 1);\n\t\t\t}\n\t\t}\n\t};\n\n\tevent_handle(array_from(all_registered_events));\n\troot_event_handles.add(event_handle);\n\n\t/** @type {Exports} */\n\t// @ts-expect-error will be defined because the render effect runs synchronously\n\tvar component = undefined;\n\n\tvar unmount = component_root(() => {\n\t\tvar anchor_node = anchor ?? target.appendChild(create_text());\n\n\t\tboundary(\n\t\t\t/** @type {TemplateNode} */ (anchor_node),\n\t\t\t{\n\t\t\t\tpending: () => {}\n\t\t\t},\n\t\t\t(anchor_node) => {\n\t\t\t\tif (context) {\n\t\t\t\t\tpush({});\n\t\t\t\t\tvar ctx = /** @type {ComponentContext} */ (component_context);\n\t\t\t\t\tctx.c = context;\n\t\t\t\t}\n\n\t\t\t\tif (events) {\n\t\t\t\t\t// We can't spread the object or else we'd lose the state proxy stuff, if it is one\n\t\t\t\t\t/** @type {any} */ (props).$$events = events;\n\t\t\t\t}\n\n\t\t\t\tif (hydrating) {\n\t\t\t\t\tassign_nodes(/** @type {TemplateNode} */ (anchor_node), null);\n\t\t\t\t}\n\n\t\t\t\tshould_intro = intro;\n\t\t\t\t// @ts-expect-error the public typings are not what the actual function looks like\n\t\t\t\tcomponent = Component(anchor_node, props) || {};\n\t\t\t\tshould_intro = true;\n\n\t\t\t\tif (hydrating) {\n\t\t\t\t\t/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;\n\n\t\t\t\t\tif (\n\t\t\t\t\t\thydrate_node === null ||\n\t\t\t\t\t\thydrate_node.nodeType !== COMMENT_NODE ||\n\t\t\t\t\t\t/** @type {Comment} */ (hydrate_node).data !== HYDRATION_END\n\t\t\t\t\t) {\n\t\t\t\t\t\tw.hydration_mismatch();\n\t\t\t\t\t\tthrow HYDRATION_ERROR;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (context) {\n\t\t\t\t\tpop();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\treturn () => {\n\t\t\tfor (var event_name of registered_events) {\n\t\t\t\ttarget.removeEventListener(event_name, handle_event_propagation);\n\n\t\t\t\tvar n = /** @type {number} */ (document_listeners.get(event_name));\n\n\t\t\t\tif (--n === 0) {\n\t\t\t\t\tdocument.removeEventListener(event_name, handle_event_propagation);\n\t\t\t\t\tdocument_listeners.delete(event_name);\n\t\t\t\t} else {\n\t\t\t\t\tdocument_listeners.set(event_name, n);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\troot_event_handles.delete(event_handle);\n\n\t\t\tif (anchor_node !== anchor) {\n\t\t\t\tanchor_node.parentNode?.removeChild(anchor_node);\n\t\t\t}\n\t\t};\n\t});\n\n\tmounted_components.set(component, unmount);\n\treturn component;\n}\n\n/**\n * References of the components that were mounted or hydrated.\n * Uses a `WeakMap` to avoid memory leaks.\n */\nlet mounted_components = new WeakMap();\n\n/**\n * Unmounts a component that was previously mounted using `mount` or `hydrate`.\n *\n * Since 5.13.0, if `options.outro` is `true`, [transitions](https://svelte.dev/docs/svelte/transition) will play before the component is removed from the DOM.\n *\n * Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).\n *\n * ```js\n * import { mount, unmount } from 'svelte';\n * import App from './App.svelte';\n *\n * const app = mount(App, { target: document.body });\n *\n * // later...\n * unmount(app, { outro: true });\n * ```\n * @param {Record<string, any>} component\n * @param {{ outro?: boolean }} [options]\n * @returns {Promise<void>}\n */\nexport function unmount(component, options) {\n\tconst fn = mounted_components.get(component);\n\n\tif (fn) {\n\t\tmounted_components.delete(component);\n\t\treturn fn(options);\n\t}\n\n\tif (DEV) {\n\t\tif (STATE_SYMBOL in component) {\n\t\t\tw.state_proxy_unmount();\n\t\t} else {\n\t\t\tw.lifecycle_double_unmount();\n\t\t}\n\t}\n\n\treturn Promise.resolve();\n}\n","import { noop } from '../../../shared/utils.js';\nimport { user_pre_effect } from '../../reactivity/effects.js';\nimport { on } from '../elements/events.js';\n\n/**\n * Substitute for the `trusted` event modifier\n * @deprecated\n * @param {(event: Event, ...args: Array<unknown>) => void} fn\n * @returns {(event: Event, ...args: unknown[]) => void}\n */\nexport function trusted(fn) {\n\treturn function (...args) {\n\t\tvar event = /** @type {Event} */ (args[0]);\n\t\tif (event.isTrusted) {\n\t\t\t// @ts-ignore\n\t\t\tfn?.apply(this, args);\n\t\t}\n\t};\n}\n\n/**\n * Substitute for the `self` event modifier\n * @deprecated\n * @param {(event: Event, ...args: Array<unknown>) => void} fn\n * @returns {(event: Event, ...args: unknown[]) => void}\n */\nexport function self(fn) {\n\treturn function (...args) {\n\t\tvar event = /** @type {Event} */ (args[0]);\n\t\t// @ts-ignore\n\t\tif (event.target === this) {\n\t\t\t// @ts-ignore\n\t\t\tfn?.apply(this, args);\n\t\t}\n\t};\n}\n\n/**\n * Substitute for the `stopPropagation` event modifier\n * @deprecated\n * @param {(event: Event, ...args: Array<unknown>) => void} fn\n * @returns {(event: Event, ...args: unknown[]) => void}\n */\nexport function stopPropagation(fn) {\n\treturn function (...args) {\n\t\tvar event = /** @type {Event} */ (args[0]);\n\t\tevent.stopPropagation();\n\t\t// @ts-ignore\n\t\treturn fn?.apply(this, args);\n\t};\n}\n\n/**\n * Substitute for the `once` event modifier\n * @deprecated\n * @param {(event: Event, ...args: Array<unknown>) => void} fn\n * @returns {(event: Event, ...args: unknown[]) => void}\n */\nexport function once(fn) {\n\tvar ran = false;\n\n\treturn function (...args) {\n\t\tif (ran) return;\n\t\tran = true;\n\n\t\t// @ts-ignore\n\t\treturn fn?.apply(this, args);\n\t};\n}\n\n/**\n * Substitute for the `stopImmediatePropagation` event modifier\n * @deprecated\n * @param {(event: Event, ...args: Array<unknown>) => void} fn\n * @returns {(event: Event, ...args: unknown[]) => void}\n */\nexport function stopImmediatePropagation(fn) {\n\treturn function (...args) {\n\t\tvar event = /** @type {Event} */ (args[0]);\n\t\tevent.stopImmediatePropagation();\n\t\t// @ts-ignore\n\t\treturn fn?.apply(this, args);\n\t};\n}\n\n/**\n * Substitute for the `preventDefault` event modifier\n * @deprecated\n * @param {(event: Event, ...args: Array<unknown>) => void} fn\n * @returns {(event: Event, ...args: unknown[]) => void}\n */\nexport function preventDefault(fn) {\n\treturn function (...args) {\n\t\tvar event = /** @type {Event} */ (args[0]);\n\t\tevent.preventDefault();\n\t\t// @ts-ignore\n\t\treturn fn?.apply(this, args);\n\t};\n}\n\n/**\n * Substitute for the `passive` event modifier, implemented as an action\n * @deprecated\n * @param {HTMLElement} node\n * @param {[event: string, handler: () => EventListener]} options\n */\nexport function passive(node, [event, handler]) {\n\tuser_pre_effect(() => {\n\t\treturn on(node, event, handler() ?? noop, {\n\t\t\tpassive: true\n\t\t});\n\t});\n}\n\n/**\n * Substitute for the `nonpassive` event modifier, implemented as an action\n * @deprecated\n * @param {HTMLElement} node\n * @param {[event: string, handler: () => EventListener]} options\n */\nexport function nonpassive(node, [event, handler]) {\n\tuser_pre_effect(() => {\n\t\treturn on(node, event, handler() ?? noop, {\n\t\t\tpassive: false\n\t\t});\n\t});\n}\n","/** @import { ComponentConstructorOptions, ComponentType, SvelteComponent, Component } from 'svelte' */\nimport { DIRTY, LEGACY_PROPS, MAYBE_DIRTY } from '../internal/client/constants.js';\nimport { user_pre_effect } from '../internal/client/reactivity/effects.js';\nimport { mutable_source, set } from '../internal/client/reactivity/sources.js';\nimport { hydrate, mount, unmount } from '../internal/client/render.js';\nimport { active_effect, get, set_signal_status } from '../internal/client/runtime.js';\nimport { flushSync } from '../internal/client/reactivity/batch.js';\nimport { define_property, is_array } from '../internal/shared/utils.js';\nimport * as e from '../internal/client/errors.js';\nimport * as w from '../internal/client/warnings.js';\nimport { DEV } from 'esm-env';\nimport { FILENAME } from '../constants.js';\nimport { component_context, dev_current_component_function } from '../internal/client/context.js';\nimport { async_mode_flag } from '../internal/flags/index.js';\n\n/**\n * Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.\n *\n * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @template {Record<string, any>} Events\n * @template {Record<string, any>} Slots\n *\n * @param {ComponentConstructorOptions<Props> & {\n * \tcomponent: ComponentType<SvelteComponent<Props, Events, Slots>> | Component<Props>;\n * }} options\n * @returns {SvelteComponent<Props, Events, Slots> & Exports}\n */\nexport function createClassComponent(options) {\n\t// @ts-expect-error $$prop_def etc are not actually defined\n\treturn new Svelte4Component(options);\n}\n\n/**\n * Takes the component function and returns a Svelte 4 compatible component constructor.\n *\n * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @template {Record<string, any>} Events\n * @template {Record<string, any>} Slots\n *\n * @param {SvelteComponent<Props, Events, Slots> | Component<Props>} component\n * @returns {ComponentType<SvelteComponent<Props, Events, Slots> & Exports>}\n */\nexport function asClassComponent(component) {\n\t// @ts-expect-error $$prop_def etc are not actually defined\n\treturn class extends Svelte4Component {\n\t\t/** @param {any} options */\n\t\tconstructor(options) {\n\t\t\tsuper({\n\t\t\t\tcomponent,\n\t\t\t\t...options\n\t\t\t});\n\t\t}\n\t};\n}\n\n/**\n * Support using the component as both a class and function during the transition period\n * @typedef  {{new (o: ComponentConstructorOptions): SvelteComponent;(...args: Parameters<Component<Record<string, any>>>): ReturnType<Component<Record<string, any>, Record<string, any>>>;}} LegacyComponentType\n */\n\nclass Svelte4Component {\n\t/** @type {any} */\n\t#events;\n\n\t/** @type {Record<string, any>} */\n\t#instance;\n\n\t/**\n\t * @param {ComponentConstructorOptions & {\n\t *  component: any;\n\t * }} options\n\t */\n\tconstructor(options) {\n\t\tvar sources = new Map();\n\n\t\t/**\n\t\t * @param {string | symbol} key\n\t\t * @param {unknown} value\n\t\t */\n\t\tvar add_source = (key, value) => {\n\t\t\tvar s = mutable_source(value, false, false);\n\t\t\tsources.set(key, s);\n\t\t\treturn s;\n\t\t};\n\n\t\t// Replicate coarse-grained props through a proxy that has a version source for\n\t\t// each property, which is incremented on updates to the property itself. Do not\n\t\t// use our $state proxy because that one has fine-grained reactivity.\n\t\tconst props = new Proxy(\n\t\t\t{ ...(options.props || {}), $$events: {} },\n\t\t\t{\n\t\t\t\tget(target, prop) {\n\t\t\t\t\treturn get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));\n\t\t\t\t},\n\t\t\t\thas(target, prop) {\n\t\t\t\t\t// Necessary to not throw \"invalid binding\" validation errors on the component side\n\t\t\t\t\tif (prop === LEGACY_PROPS) return true;\n\n\t\t\t\t\tget(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));\n\t\t\t\t\treturn Reflect.has(target, prop);\n\t\t\t\t},\n\t\t\t\tset(target, prop, value) {\n\t\t\t\t\tset(sources.get(prop) ?? add_source(prop, value), value);\n\t\t\t\t\treturn Reflect.set(target, prop, value);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tthis.#instance = (options.hydrate ? hydrate : mount)(options.component, {\n\t\t\ttarget: options.target,\n\t\t\tanchor: options.anchor,\n\t\t\tprops,\n\t\t\tcontext: options.context,\n\t\t\tintro: options.intro ?? false,\n\t\t\trecover: options.recover\n\t\t});\n\n\t\t// We don't flushSync for custom element wrappers or if the user doesn't want it,\n\t\t// or if we're in async mode since `flushSync()` will fail\n\t\tif (!async_mode_flag && (!options?.props?.$$host || options.sync === false)) {\n\t\t\tflushSync();\n\t\t}\n\n\t\tthis.#events = props.$$events;\n\n\t\tfor (const key of Object.keys(this.#instance)) {\n\t\t\tif (key === '$set' || key === '$destroy' || key === '$on') continue;\n\t\t\tdefine_property(this, key, {\n\t\t\t\tget() {\n\t\t\t\t\treturn this.#instance[key];\n\t\t\t\t},\n\t\t\t\t/** @param {any} value */\n\t\t\t\tset(value) {\n\t\t\t\t\tthis.#instance[key] = value;\n\t\t\t\t},\n\t\t\t\tenumerable: true\n\t\t\t});\n\t\t}\n\n\t\tthis.#instance.$set = /** @param {Record<string, any>} next */ (next) => {\n\t\t\tObject.assign(props, next);\n\t\t};\n\n\t\tthis.#instance.$destroy = () => {\n\t\t\tunmount(this.#instance);\n\t\t};\n\t}\n\n\t/** @param {Record<string, any>} props */\n\t$set(props) {\n\t\tthis.#instance.$set(props);\n\t}\n\n\t/**\n\t * @param {string} event\n\t * @param {(...args: any[]) => any} callback\n\t * @returns {any}\n\t */\n\t$on(event, callback) {\n\t\tthis.#events[event] = this.#events[event] || [];\n\n\t\t/** @param {any[]} args */\n\t\tconst cb = (...args) => callback.call(this, ...args);\n\t\tthis.#events[event].push(cb);\n\t\treturn () => {\n\t\t\tthis.#events[event] = this.#events[event].filter(/** @param {any} fn */ (fn) => fn !== cb);\n\t\t};\n\t}\n\n\t$destroy() {\n\t\tthis.#instance.$destroy();\n\t}\n}\n\n/**\n * Runs the given function once immediately on the server, and works like `$effect.pre` on the client.\n *\n * @deprecated Use this only as a temporary solution to migrate your component code to Svelte 5.\n * @param {() => void | (() => void)} fn\n * @returns {void}\n */\nexport function run(fn) {\n\tuser_pre_effect(() => {\n\t\tfn();\n\t\tvar effect = /** @type {import('#client').Effect} */ (active_effect);\n\t\t// If the effect is immediately made dirty again, mark it as maybe dirty to emulate legacy behaviour\n\t\tif ((effect.f & DIRTY) !== 0) {\n\t\t\tlet filename = \"a file (we can't know which one)\";\n\t\t\tif (DEV) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tfilename = dev_current_component_function?.[FILENAME] ?? filename;\n\t\t\t}\n\t\t\tw.legacy_recursive_reactive_block(filename);\n\t\t\tset_signal_status(effect, MAYBE_DIRTY);\n\t\t}\n\t});\n}\n\n/**\n * Function to mimic the multiple listeners available in svelte 4\n * @deprecated\n * @param {EventListener[]} handlers\n * @returns {EventListener}\n */\nexport function handlers(...handlers) {\n\treturn function (event) {\n\t\tconst { stopImmediatePropagation } = event;\n\t\tlet stopped = false;\n\n\t\tevent.stopImmediatePropagation = () => {\n\t\t\tstopped = true;\n\t\t\tstopImmediatePropagation.call(event);\n\t\t};\n\n\t\tconst errors = [];\n\n\t\tfor (const handler of handlers) {\n\t\t\ttry {\n\t\t\t\t// @ts-expect-error `this` is not typed\n\t\t\t\thandler?.call(this, event);\n\t\t\t} catch (e) {\n\t\t\t\terrors.push(e);\n\t\t\t}\n\n\t\t\tif (stopped) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (let error of errors) {\n\t\t\tqueueMicrotask(() => {\n\t\t\t\tthrow error;\n\t\t\t});\n\t\t}\n\t};\n}\n\n/**\n * Function to create a `bubble` function that mimic the behavior of `on:click` without handler available in svelte 4.\n * @deprecated Use this only as a temporary solution to migrate your automatically delegated events in Svelte 5.\n */\nexport function createBubbler() {\n\tconst active_component_context = component_context;\n\tif (active_component_context === null) {\n\t\te.lifecycle_outside_component('createBubbler');\n\t}\n\n\treturn (/**@type {string}*/ type) => (/**@type {Event}*/ event) => {\n\t\tconst events = /** @type {Record<string, Function | Function[]>} */ (\n\t\t\tactive_component_context.s.$$events\n\t\t)?.[/** @type {any} */ (type)];\n\n\t\tif (events) {\n\t\t\tconst callbacks = is_array(events) ? events.slice() : [events];\n\t\t\tfor (const fn of callbacks) {\n\t\t\t\tfn.call(active_component_context.x, event);\n\t\t\t}\n\t\t\treturn !event.defaultPrevented;\n\t\t}\n\t\treturn true;\n\t};\n}\n\nexport {\n\tonce,\n\tpreventDefault,\n\tself,\n\tstopImmediatePropagation,\n\tstopPropagation,\n\ttrusted,\n\tpassive,\n\tnonpassive\n} from '../internal/client/dom/legacy/event-modifiers.js';\n"],"mappings":"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"}